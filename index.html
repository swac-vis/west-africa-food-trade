<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>African Food Flows - Complete Visualization</title>
    <script src="https://unpkg.com/deck.gl@latest/dist.min.js"></script>
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
            background: #0a1929;
        }

        .header {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            padding: 20px 25px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 10;
            max-width: 350px;
            border: 1px solid rgba(0,0,0,0.06);
        }

        .header h1 {
            font-size: 1.5rem;
            margin-bottom: 5px;
            color: #1a202c;
            font-weight: 700;
        }

        .header .subtitle {
            font-size: 0.85rem;
            color: #718096;
            line-height: 1.4;
        }

        .control-panel {
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            padding: 16px 12px;
            box-shadow: 2px 0 12px rgba(0,0,0,0.08);
            width: 260px;
            max-width: 90vw;
            overflow-x: visible;
            overflow-y: auto;
            z-index: 10;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-right: 1px solid rgba(0,0,0,0.06);
        }
        
        .control-panel.collapsed {
            transform: translateX(-260px);
        }
        
        .control-panel-toggle {
            position: fixed;
            top: 50%;
            left: 260px;
            transform: translateY(-50%);
            width: 20px;
            height: 80px;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0,0,0,0.06);
            border-left: none;
            border-radius: 0 6px 6px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            color: #4a5568;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 2px 0 8px rgba(0,0,0,0.06);
            z-index: 11;
        }
        
        .control-panel-toggle:hover {
            background: white;
            color: #007bff;
            width: 36px;
            box-shadow: 2px 0 12px rgba(0,0,0,0.12);
        }
        
        .control-panel-toggle::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 100%;
            margin-left: 8px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        
        .control-panel-toggle:hover::after {
            opacity: 1;
        }
        
        .control-panel-toggle.collapsed {
            left: 0;
        }
        
        /* Ensure panel content doesn't overflow horizontally */
        .control-panel * {
            max-width: 100%;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .control-panel {
                width: 240px;
            }
            
            .control-panel-toggle {
                left: 240px;
            }
            
            .control-panel.collapsed {
                transform: translateX(-240px);
            }
        }

        .control-panel h3 {
            font-size: 0.85rem;
            margin-bottom: 16px;
            margin-top: 0;
            color: #2d3748;
            font-weight: 600;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group {
            margin-bottom: 14px;
            width: 100%;
            overflow: hidden;
        }
        
        .control-group:first-of-type {
            margin-top: 0;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #4a5568;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        select, input[type="range"] {
            width: 100%;
            max-width: 100%;
            padding: 8px 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 0.875rem;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }

        select:focus {
            outline: none;
            border-color: #4299e1;
        }

        input[type="range"] {
            padding: 0;
            height: 6px;
            cursor: pointer;
        }

        /* 极简交互图表 */
        .filter-chart {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 6px;
        }

        .filter-bars {
            display: flex;
            flex-direction: column;
            gap: 3px;
            max-height: 200px;
            overflow-y: auto;
            overflow-x: hidden;
            width: 100%;
        }

        .filter-bar-item {
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: all 0.15s;
            padding: 3px 5px;
            border-radius: 3px;
            background: white;
            border: 1px solid transparent;
        }

        .filter-bar-item:hover {
            background: #f1f3f4;
            border-color: #dee2e6;
        }

        .filter-bar-item.active {
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }

        .filter-bar-label {
            min-width: 70px;
            font-size: 0.65rem;
            font-weight: 500;
        }

        .bar-container {
            flex: 1;
            height: 10px;
            background: #e9ecef;
            border-radius: 2px;
            overflow: hidden;
            margin: 0 5px;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            background: #6c757d;
            border-radius: 2px;
            transition: width 0.2s ease;
        }

        .filter-bar-item.active .bar-fill {
            background: white;
        }

        .bar-value {
            font-size: 0.6rem;
            font-weight: 600;
            min-width: 30px;
            text-align: right;
            color: #6c757d;
        }

        .filter-bar-item.active .bar-value {
            color: white;
        }

        /* 年份时间轴 */
        .year-timeline {
            display: flex;
            gap: 3px;
            margin-top: 6px;
        }

        .year-button {
            flex: 1;
            padding: 6px 4px;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 3px;
            font-size: 0.65rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
        }

        .year-button:hover {
            border-color: #007bff;
            background: #f8f9ff;
        }

        .year-button.active {
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }

        /* 商品网格 */
        .commodity-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 3px;
            margin-top: 6px;
            max-height: 200px;
            overflow-y: auto;
            overflow-x: hidden;
            width: 100%;
        }

        .commodity-card {
            padding: 4px 3px;
            border: 1px solid #dee2e6;
            border-radius: 3px;
            background: white;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
        }

        .commodity-card:hover {
            border-color: #007bff;
            background: #f8f9ff;
        }

        .commodity-card.active {
            background: #007bff;
            border-color: #0056b3;
            color: white;
        }

        .commodity-card.active .commodity-bar {
            background: white !important;
        }

        .commodity-name {
            font-size: 0.6rem;
            font-weight: 500;
            margin-bottom: 1px;
            line-height: 1.1;
        }

        .commodity-count {
            font-size: 0.55rem;
            opacity: 0.8;
            line-height: 1;
        }

        /* 统计图表样式 */
        .stats-chart {
            display: flex;
            align-items: end;
            gap: 2px;
            height: 40px;
            margin: 6px 0 24px 0;
            padding: 4px;
            background: #f8f9fa;
            border-radius: 3px;
            width: 100%;
            overflow: visible;
            position: relative;
        }

        .stat-bar {
            flex: 1;
            background: #6c757d;
            border-radius: 2px 2px 0 0;
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
            height: 20%; /* Default height before data loads */
        }

        .stat-bar:hover {
            background: #007bff;
        }

        .stat-bar.active {
            background: #007bff;
        }

        .stat-bar-label {
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.6rem;
            color: #6c757d;
            white-space: nowrap;
        }

        .stat-bar.active .stat-bar-label {
            color: #007bff;
            font-weight: 600;
        }

        /* 横向堆叠条形图 */
        .stacked-bar-container {
            margin: 6px 0;
            width: 100%;
            overflow: hidden;
        }

        .stacked-bar-chart {
            display: flex;
            width: 100%;
            height: 28px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
        }

        .stacked-bar-segment {
            height: 100%;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid rgba(255,255,255,0.3);
        }

        .stacked-bar-segment:last-child {
            border-right: none;
        }

        .stacked-bar-segment:hover {
            filter: brightness(1.1);
        }

        .stacked-bar-segment.selected {
            filter: brightness(1.2);
            box-shadow: inset 0 0 0 2px rgba(255,255,255,0.5);
        }

        .stacked-bar-label {
            font-size: 0.65rem;
            font-weight: 600;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1.2;
        }

        .stacked-bar-label-year {
            font-size: 0.7rem;
        }

        .stacked-bar-label-count {
            font-size: 0.6rem;
            opacity: 0.9;
        }

        .stacked-bar-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
            padding: 6px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .legend-item-compact {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.65rem;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            transition: all 0.15s;
        }

        .legend-item-compact:hover {
            background: white;
        }

        .legend-item-compact.selected {
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .legend-color-box {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            flex-shrink: 0;
        }

        .legend-item-compact .legend-label {
            color: #495057;
            font-weight: 500;
        }

        .legend-item-compact.selected .legend-label {
            color: #007bff;
            font-weight: 600;
        }

        .legend-item-compact .legend-value {
            color: #6c757d;
            margin-left: 2px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
            width: 100%;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 10px 8px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #e9ecef;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: #2d3748;
            line-height: 1;
        }

        .stat-label {
            font-size: 0.65rem;
            color: #718096;
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .legend {
            margin-top: 14px;
            padding-top: 14px;
            border-top: 2px solid #e9ecef;
            width: 100%;
            overflow: hidden;
        }

        .legend-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            font-size: 0.75rem;
        }

        .legend-line {
            width: 35px;
            height: 3px;
            margin-right: 10px;
            border-radius: 2px;
        }

        .legend-triangle {
            width: 0;
            height: 0;
            margin-right: 10px;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
        }

        .legend-triangle-up {
            border-bottom: 14px solid;
        }

        .legend-triangle-down {
            border-top: 14px solid;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-top: 8px;
            padding: 6px 10px;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }

        .checkbox-group label {
            margin: 0;
            font-weight: 500;
            cursor: pointer;
            font-size: 0.7rem;
            color: #495057;
            flex: 1;
        }

        /* Custom toggle switch */
        .toggle-switch {
            position: relative;
            width: 36px;
            height: 18px;
            flex-shrink: 0;
            display: inline-block;
        }

        .toggle-switch input[type="checkbox"] {
            opacity: 0;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            margin: 0;
            cursor: pointer;
            z-index: 2;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #cbd5e0;
            transition: 0.2s;
            border-radius: 18px;
            pointer-events: none;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: 0.2s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #007bff;
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(18px);
        }

        .toggle-switch:hover .toggle-slider {
            background-color: #a0aec0;
        }

        .toggle-switch input:checked:hover + .toggle-slider {
            background-color: #0056b3;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px 60px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            z-index: 1000;
            text-align: center;
        }

        .loading-spinner {
            font-size: 3rem;
            margin-bottom: 15px;
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.1rem;
            color: #2d3748;
            font-weight: 600;
        }

        .loading-subtext {
            font-size: 0.9rem;
            color: #718096;
            margin-top: 8px;
        }

        .tooltip {
            position: absolute;
            padding: 12px 16px;
            background: rgba(26, 32, 44, 0.95);
            color: white;
            border-radius: 8px;
            pointer-events: none;
            z-index: 100;
            font-size: 0.875rem;
            max-width: 280px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            display: none;
        }

        .tooltip-title {
            font-weight: 700;
            margin-bottom: 6px;
            font-size: 0.95rem;
        }

        .tooltip-item {
            margin: 4px 0;
            font-size: 0.85rem;
        }

        .tooltip-commodities {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.2);
            font-size: 0.8rem;
        }

        .range-value {
            display: inline-block;
            background: #4299e1;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            margin-left: 8px;
            font-weight: 600;
        }

        .control-panel::-webkit-scrollbar {
            width: 4px;
        }

        .control-panel::-webkit-scrollbar-track {
            background: transparent;
        }

        .control-panel::-webkit-scrollbar-thumb {
            background: rgba(0,0,0,0.1);
            border-radius: 2px;
        }

        .control-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(0,0,0,0.2);
        }
        
        /* For other scrollable areas */
        .filter-bars::-webkit-scrollbar,
        .commodity-grid::-webkit-scrollbar {
            width: 4px;
        }

        .filter-bars::-webkit-scrollbar-track,
        .commodity-grid::-webkit-scrollbar-track {
            background: #f8f9fa;
        }

        .filter-bars::-webkit-scrollbar-thumb,
        .commodity-grid::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 2px;
        }

        .filter-bars::-webkit-scrollbar-thumb:hover,
        .commodity-grid::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }

    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="loading" id="loading">
        <div class="loading-spinner">🌍</div>
        <div class="loading-text">Loading African Food Flows</div>
        <div class="loading-subtext">Preparing 80,762 trade records...</div>
    </div>

    <div class="header">
        <h1>🌾 African Food Flows</h1>
        <div class="subtitle">
            Visualizing food trade in west africa from 2013-2017. 
            Complete dataset with 80,762 recorded trades.
        </div>
    </div>

    <div class="control-panel-toggle" id="panelToggle" onclick="toggleControlPanel()" data-tooltip="Hide filters (F)" style="display: none;">
        <span id="toggleIcon">◀</span>
        </div>

    <div class="control-panel" id="control-panel" style="display: none;">
        <h3>Filters</h3>
            <!-- Color Mode -->
            <div class="control-group">
                <label>Color Mode</label>
                <div class="filter-bars">
                    <div class="filter-bar-item active color-mode-bar" data-mode="source_destination" onclick="selectColorMode(this, 'source_destination')">
                        <span class="filter-bar-label">Source-Dest</span>
                        <div class="bar-container"><div class="bar-fill"></div></div>
                        <span class="bar-value">Default</span>
                    </div>
                    <div class="filter-bar-item color-mode-bar" data-mode="rural_urban" onclick="selectColorMode(this, 'rural_urban')">
                        <span class="filter-bar-label">Rural-Urban</span>
                        <div class="bar-container"><div class="bar-fill"></div></div>
                        <span class="bar-value"></span>
                    </div>
                    <div class="filter-bar-item color-mode-bar" data-mode="international" onclick="selectColorMode(this, 'international')">
                        <span class="filter-bar-label">Trade Type</span>
                        <div class="bar-container"><div class="bar-fill"></div></div>
                        <span class="bar-value"></span>
                    </div>
                </div>
            </div>

            <!-- Rural-Urban Flow Pattern (always visible) -->
            <div class="control-group" id="ruralUrbanFilterGroup">
                <label>Flow Pattern</label>
                <div class="stacked-bar-container">
                    <div class="stacked-bar-chart" id="ruralUrbanStackedBar">
                        <!-- Dynamically generated -->
                    </div>
                </div>
            </div>

            <!-- Trade Type (always visible) -->
            <div class="control-group" id="tradeTypeFilterGroup">
                <label>Trade Type</label>
                <div class="stacked-bar-container">
                    <div class="stacked-bar-chart" id="tradeTypeStackedBar">
                        <!-- Dynamically generated -->
                    </div>
                </div>
            </div>

            <!-- Year Distribution -->
            <div class="control-group">
                <label>Year Distribution</label>
                <div class="stacked-bar-container">
                    <div class="stacked-bar-chart" id="yearStackedBar">
                        <!-- Dynamically generated -->
                    </div>
                </div>
            </div>

            <!-- Commodities -->
            <div class="control-group">
                <label id="commodityLabel">Commodities</label>
                <div class="commodity-grid" id="commodityGrid" style="max-height: 250px;">
                    <!-- Dynamically generated from data -->
                </div>
            </div>

            <!-- Transport Modes -->
            <div class="control-group">
                <label id="transportLabel">Transport</label>
                <div class="filter-bars" id="transportBars" style="max-height: 250px;">
                    <!-- Dynamically generated from data -->
                </div>
            </div>

            <!-- Via City (Transit) -->
            <div class="control-group">
                <label id="viaCityLabel">Transit Cities</label>
                <div class="filter-bars" id="viaCityBars" style="max-height: 250px;">
                    <!-- Dynamically generated from data -->
                </div>
            </div>

            <!-- Route Filter -->
            <div class="control-group">
                <label>Route Filter</label>
                <div class="stats-chart">
                    <div class="stat-bar active" onclick="selectRouteFilterStat(this, 'all')">
                        <div class="stat-bar-label">All</div>
                    </div>
                    <div class="stat-bar" onclick="selectRouteFilterStat(this, 'major')">
                        <div class="stat-bar-label">Major</div>
                    </div>
                    <div class="stat-bar" onclick="selectRouteFilterStat(this, 'top100')">
                        <div class="stat-bar-label">Top100</div>
                    </div>
                    <div class="stat-bar" onclick="selectRouteFilterStat(this, 'heatmap')">
                        <div class="stat-bar-label">Heatmap</div>
                </div>
            </div>
        </div>

        <div class="control-group">
            <label>
                Arc Thickness
                <span class="range-value" id="arcWidthValue">0.3</span>
            </label>
            <input type="range" id="arcWidth" min="0.1" max="5" value="0.3" step="0.1">
        </div>

        <div class="checkbox-group">
                <label for="showArcs">📈 Flow arcs</label>
                <div class="toggle-switch">
                    <input type="checkbox" id="showArcs" checked>
                    <span class="toggle-slider"></span>
                </div>
            </div>

            <div class="checkbox-group">
                <label for="showPoints">📍 Location points</label>
                <div class="toggle-switch">
            <input type="checkbox" id="showPoints" checked>
                    <span class="toggle-slider"></span>
                </div>
        </div>

        <div class="checkbox-group">
                <label for="showViaCity">⤴ Transit cities</label>
                <div class="toggle-switch">
            <input type="checkbox" id="showViaCity">
                    <span class="toggle-slider"></span>
                </div>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="visibleRoutes">-</div>
                <div class="stat-label" id="routesLabel">Routes</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalFlows">-</div>
                <div class="stat-label">Quantity</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="intlFlows">-</div>
                <div class="stat-label">International</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avgDistance">-</div>
                <div class="stat-label" id="distanceLabel">Avg Distance</div>
            </div>
        </div>

        <div class="legend" id="legendRuralUrban" style="display: none;">
            <div class="legend-title">Point Encoding</div>
            <div class="legend-item">
                <div class="legend-triangle legend-triangle-up" style="border-bottom-color: #FBE819;"></div>
                <span>Urban Source</span>
            </div>
            <div class="legend-item">
                <div class="legend-triangle legend-triangle-down" style="border-top-color: #FBE819;"></div>
                <span>Urban Destination</span>
            </div>
            <div class="legend-item">
                <div class="legend-triangle legend-triangle-up" style="border-bottom-color: #2A50EA;"></div>
                <span>Rural Source</span>
            </div>
            <div class="legend-item">
                <div class="legend-triangle legend-triangle-down" style="border-top-color: #2A50EA;"></div>
                <span>Rural Destination</span>
            </div>
        </div>

        <div class="legend" id="legendInternational" style="display: none;">
            <div class="legend-title">Flow Types (Arc Color)</div>
            <div class="legend-item">
                <div class="legend-line" style="background: #e53e3e;"></div>
                <span>🌐 International (6.9%)</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #3182ce;"></div>
                <span>🏠 Domestic (93.1%)</span>
            </div>
            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #edf2f7;">
                <div class="legend-title" style="margin-bottom: 8px;">Point Direction</div>
                <div class="legend-item">
                    <div class="legend-triangle legend-triangle-up" style="border-bottom-color: #888;"></div>
                    <span style="font-size: 0.85rem;">Source</span>
                </div>
                <div class="legend-item">
                    <div class="legend-triangle legend-triangle-down" style="border-top-color: #888;"></div>
                    <span style="font-size: 0.85rem;">Destination</span>
                </div>
            </div>
        </div>

        <div class="legend" id="legendSourceDest">
            <div class="legend-title">Point Type</div>
            <div class="legend-item">
                <div class="legend-triangle legend-triangle-up" style="border-bottom-color: #10b981;"></div>
                <span>Source (origin points)</span>
            </div>
            <div class="legend-item">
                <div class="legend-triangle legend-triangle-down" style="border-top-color: #ef4444;"></div>
                <span>Destination (arrival points)</span>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>


    <script>
        const {DeckGL, ArcLayer, ScatterplotLayer, HeatmapLayer, IconLayer, PathLayer} = deck;

        let allDataByYear = null; // New hierarchical data: year → route_id → route data
        let allRoutesFlat = []; // Flattened array of all routes for compatibility
        let currentDataSource = 'all';
        let filteredRoutes = [];
        let deckgl = null;
        let colorMode = 'source_destination'; // Color mode: 'source_destination', 'rural_urban', or 'international'
        
        // Global statistics for legend (all available options without any filters)
        let globalStats = {
            years: new Map(),
            ruralUrban: new Map(),
            tradeTypes: new Map()
        };
        let hoveredRoute = null; // Currently hovered route
        let selectedRoute = null; // Currently selected (clicked) route
        let selectedPoint = null; // Currently selected point {position: [lon, lat], type: 'source'|'destination'}
        

        // New hierarchical data file - organized by year
        const DATA_FILE = 'food_flows_by_year.json';

        // Global commodity mapping (lowercase key -> Exact data name from JSON)
        const COMMODITY_MAP = {
            'maize': 'Maize', 
            'rice': 'Rice', 
            'onion': 'Onion', 
            'sheep': 'Sheep',
            'yam': 'Yam', 
            'potato': 'Potato', 
            'groundnut': 'Groundnut', 
            'tomato': 'Tomato',
            'chilli_pepper': 'Chilli pepper', 
            'plantain': 'Plantain', 
            'cattle': 'Cattle',
            'fish': 'Fish', 
            'bean': 'Bean', 
            'millet': 'Millet',
            'chicken': 'Chicken',
            'mango': 'Mango',
            'cabbage': 'Cabbage',
            'banana': 'Banana',
            'goat': 'Goat',
            'soybean': 'Soybean',
            'cocoyam': 'Cocoyam',
            'eggplant': 'Eggplant',
            'gari': 'Gari',
            'watermelon': 'Watermelon',
            'okra': 'Okra',
            'cassava': 'Cassava',
            'orange': 'Orange',
            'sweet_potato': 'Sweet potato',  // 注意：小写p
            'wheat_flour': 'Wheat flour',
            'wheat': 'Wheat',
            'sorghum': 'Sorghum',
            'cucumber': 'Cucumber',
            'avocado': 'Avocado',
            'pig': 'Pig',
            'papaya': 'Papaya',
            'zucchini': 'Zucchini',
            'pineapple': 'Pineapple',
            'spring_onion': 'Spring onion',
            'guinea_fowl': 'Guinew fowl',  // 注意：数据中是Guinew，不是Guinea
            'leeks': 'Leeks',
            'sweet_pepper': 'Sweet pepper',
            'ginger': 'Ginger',
            'carrot': 'Carrot',
            'cowpea': 'Cowpea',
            'green_bean': 'Green bean',
            'bambara_beans': 'Bambara beans'
        };

        // Color configurations for stacked bar charts - use blue tones
        const STACKED_BAR_COLORS = {
            '2013': '#4A90E2',
            '2014': '#5B9FED', 
            '2015': '#6CAEF8',
            '2016': '#7DBDFF',
            '2017': '#8ECCFF',
            'rural_to_urban': '#4A90E2',
            'urban_to_rural': '#5B9FED',
            'rural_to_rural': '#6CAEF8',
            'urban_to_urban': '#7DBDFF',
            'international': '#4A90E2',
            'domestic': '#6CAEF8'
        };

        const FLOW_PATTERN_LABELS = {
            'rural_to_urban': 'R→U',
            'urban_to_rural': 'U→R',
            'rural_to_rural': 'R→R',
            'urban_to_urban': 'U→U'
        };

        const TRADE_TYPE_LABELS = {
            'international': 'International',
            'domestic': 'Domestic'
        };

        // Reverse mapping (Data name -> Display name)
        const COMMODITY_DISPLAY_MAP = {};
        Object.entries(COMMODITY_MAP).forEach(([key, value]) => {
            COMMODITY_DISPLAY_MAP[value] = value.charAt(0).toUpperCase() + value.slice(1);
        });

        /**
         * Generate dynamic filter options from loaded data
         */
        /**
         * Initialize all stat bars with actual data on page load
         */
        function initializeStatBars() {
            if (!allRoutesFlat || allRoutesFlat.length === 0) return;
            
            // Calculate all statistics from allRoutesFlat
            const stats = {
                years: new Map(),
                ruralUrban: new Map(),
                tradeTypes: new Map(),
                routeFilters: {
                    all: allRoutesFlat.length,
                    major: allRoutesFlat.filter(d => (d.flows || 0) >= 10).length,
                    top100: 100,
                    heatmap: allRoutesFlat.length  // Same as all for visual purposes
                }
            };
            
            allRoutesFlat.forEach(route => {
                // Year statistics - use quantity instead of flows
                if (route.by_year) {
                    Object.entries(route.by_year).forEach(([year, data]) => {
                        const count = stats.years.get(year) || 0;
                        stats.years.set(year, count + (data.quantity || 0));
                    });
                }
                
                // Rural-Urban statistics - use quantity instead of flows
                const flowType = route.flow_type;
                if (flowType) {
                    const count = stats.ruralUrban.get(flowType) || 0;
                    stats.ruralUrban.set(flowType, count + (route.quantity || 0));
                }
                
                // Trade type statistics - use quantity instead of flows
                const trade = route.is_international ? 'international' : 'domestic';
                const tradeCount = stats.tradeTypes.get(trade) || 0;
                stats.tradeTypes.set(trade, tradeCount + (route.quantity || 0));
            });
            
            // Save global stats for legend display
            globalStats.years = new Map(stats.years);
            globalStats.ruralUrban = new Map(stats.ruralUrban);
            globalStats.tradeTypes = new Map(stats.tradeTypes);
            
            // Update Year stat bars
            updateYearFilterOptions(stats.years);
            
            // Update Rural-Urban stat bars
            updateRuralUrbanFilterOptions(stats.ruralUrban);
            
            // Update Trade Type stat bars
            updateTradeTypeFilterOptions(stats.tradeTypes);
            
            // Update Route Filter stat bars
            updateRouteFilterBars(stats.routeFilters);
            
            // Update Color Mode bars
            updateColorModeBars(stats.ruralUrban, stats.tradeTypes);
        }

        function generateFilterOptionsFromData() {
            if (!allRoutesFlat || allRoutesFlat.length === 0) return;
            
            // Calculate commodity counts - use quantity for statistics
            const commodityCounts = new Map();
            allRoutesFlat.forEach(route => {
                if (route.by_commodity) {
                    Object.entries(route.by_commodity).forEach(([commodity, data]) => {
                        const count = commodityCounts.get(commodity) || 0;
                        commodityCounts.set(commodity, count + (data.quantity || 0));
                    });
                }
            });
            
            // Calculate transport counts - use quantity for statistics
            const transportCounts = new Map();
            allRoutesFlat.forEach(route => {
                if (route.by_transport) {
                    Object.entries(route.by_transport).forEach(([transport, data]) => {
                        const count = transportCounts.get(transport) || 0;
                        transportCounts.set(transport, count + (data.quantity || 0));
                    });
                }
            });
            
            // Calculate via city counts - use quantity for statistics
            const viaCityCounts = new Map();
            allRoutesFlat.forEach(route => {
                const viaCityName = route.via_city && route.via_city.name ? route.via_city.name : 'Direct';
                const count = viaCityCounts.get(viaCityName) || 0;
                viaCityCounts.set(viaCityName, count + (route.quantity || 0));
            });
            
            // Update label with count
            document.getElementById('commodityLabel').textContent = `Commodities (${commodityCounts.size} types)`;
            document.getElementById('transportLabel').textContent = `Transport (${transportCounts.size} modes)`;
            const viaCityLabel = document.getElementById('viaCityLabel');
            if (viaCityLabel) {
                viaCityLabel.textContent = `Transit Cities (${viaCityCounts.size} types)`;
            }
            
            // Generate commodity cards
            generateCommodityCards(commodityCounts);
            
            // Generate transport bars
            generateTransportBars(transportCounts);
            
            // Generate via city bars
            generateViaCityBars(viaCityCounts);
        }

        function generateCommodityCards(commodityCounts) {
            const grid = document.getElementById('commodityGrid');
            grid.innerHTML = ''; // Clear existing
            
            // Calculate total flows for "All"
            const totalFlows = Array.from(commodityCounts.values()).reduce((a, b) => a + b, 0);
            
            // Find max count for color scaling
            const maxCount = commodityCounts.size > 0 ? Math.max(...commodityCounts.values()) : 0;
            
            // Add "All" option first
            const allCard = document.createElement('div');
            allCard.className = 'commodity-card active';
            allCard.onclick = function() { selectCommodity(this, 'all'); };
            allCard.innerHTML = `
                <div class="commodity-name">All</div>
                <div class="commodity-count">${formatQuantity(totalFlows)}</div>
            `;
            grid.appendChild(allCard);
            
            // Sort commodities by count (descending)
            const sortedCommodities = Array.from(commodityCounts.entries())
                .sort((a, b) => b[1] - a[1]);
            
            // Generate card for each commodity
            sortedCommodities.forEach(([commodity, count]) => {
                // Find the key for this commodity
                let commodityKey = null;
                for (const [key, value] of Object.entries(COMMODITY_MAP)) {
                    if (value === commodity) {
                        commodityKey = key;
                        break;
                    }
                }
                
                // If no key found, create one from commodity name
                if (!commodityKey) {
                    commodityKey = commodity.toLowerCase().replace(/[^a-z0-9]+/g, '_');
                    COMMODITY_MAP[commodityKey] = commodity;
                }
                
                // Calculate intensity for bar chart (0-100)
                const intensity = maxCount > 0 ? Math.round((count / maxCount) * 100) : 0;
                
                const card = document.createElement('div');
                card.className = 'commodity-card';
                card.onclick = function() { selectCommodity(this, commodityKey); };
                card.innerHTML = `
                    <div class="commodity-name">${commodity}</div>
                    <div class="commodity-count">${formatQuantity(count)}</div>
                    <div class="commodity-bar" style="width: ${intensity}%; height: 2px; background: #6c757d; margin-top: 3px; border-radius: 1px;"></div>
                `;
                grid.appendChild(card);
            });
        }

        function generateTransportBars(transportCounts) {
            const container = document.getElementById('transportBars');
            container.innerHTML = ''; // Clear existing
            
            // Calculate total for percentages
            const total = Array.from(transportCounts.values()).reduce((a, b) => a + b, 0);
            
            // Add "All" option first
            const allBar = document.createElement('div');
            allBar.className = 'filter-bar-item active';
            allBar.onclick = function() { selectTransport(this, 'all'); };
            allBar.innerHTML = `
                <span class="filter-bar-label">All Modes</span>
                <div class="bar-container"><div class="bar-fill" style="width: 100%"></div></div>
                <span class="bar-value">100%</span>
            `;
            container.appendChild(allBar);
            
            // Sort transports by count (descending)
            const sortedTransports = Array.from(transportCounts.entries())
                .sort((a, b) => b[1] - a[1]);
            
            // Generate bar for each transport mode
            sortedTransports.forEach(([transport, count]) => {
                const percentage = Math.round((count / total) * 100);
                const bar = document.createElement('div');
                bar.className = 'filter-bar-item';
                bar.onclick = function() { selectTransport(this, transport); };
                bar.innerHTML = `
                    <span class="filter-bar-label">${transport}</span>
                    <div class="bar-container"><div class="bar-fill" style="width: ${percentage}%"></div></div>
                    <span class="bar-value">${percentage}%</span>
                `;
                container.appendChild(bar);
            });
        }

        function generateViaCityBars(viaCityCounts) {
            const container = document.getElementById('viaCityBars');
            if (!container) return; // Skip if container doesn't exist yet
            
            container.innerHTML = ''; // Clear existing
            
            // Calculate total for percentages
            const total = Array.from(viaCityCounts.values()).reduce((a, b) => a + b, 0);
            if (total === 0) return;
            
            // Add "All" option first
            const allBar = document.createElement('div');
            allBar.className = 'filter-bar-item active';
            allBar.onclick = function() { selectViaCity(this, 'all'); };
            allBar.innerHTML = `
                <span class="filter-bar-label">All Routes</span>
                <div class="bar-container"><div class="bar-fill" style="width: 100%"></div></div>
                <span class="bar-value">100%</span>
            `;
            container.appendChild(allBar);
            
            // Sort via cities by count (descending)
            const sortedCities = Array.from(viaCityCounts.entries())
                    .sort((a, b) => b[1] - a[1]);
                
            // Generate bar for each via city
            sortedCities.forEach(([cityName, count]) => {
                const percentage = Math.round((count / total) * 100);
                const bar = document.createElement('div');
                bar.className = 'filter-bar-item';
                bar.onclick = function() { selectViaCity(this, cityName); };
                const icon = cityName === 'Direct' ? '→' : '⤴';
                bar.innerHTML = `
                    <span class="filter-bar-label">${icon} ${cityName}</span>
                    <div class="bar-container"><div class="bar-fill" style="width: ${percentage}%"></div></div>
                    <span class="bar-value">${percentage}%</span>
                `;
                container.appendChild(bar);
            });
        }

        async function init() {
            try {
                // Load all data once (21MB)
                await loadAllData();
                
                // Filter initial data (all routes)
                filteredRoutes = getFilteredDataBySource('all');

                document.getElementById('loading').style.display = 'none';
                document.getElementById('control-panel').style.display = 'block';
                document.getElementById('panelToggle').style.display = 'flex';

                initDeckGL();
                updateStats();  // Update statistics on initial load
                updateVisualization();
                
                // Generate dynamic filter options from data
                generateFilterOptionsFromData();
                
                // Initialize all stat bar heights based on actual data
                initializeStatBars();
                
                setupEventListeners();

            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').innerHTML = 
                    '<div class="loading-text">❌ Error loading data</div><div class="loading-subtext">' + error.message + '</div>';
            }
        }

        // Load hierarchical data and convert to flat array for compatibility
        async function loadAllData() {
            if (allDataByYear) return allRoutesFlat; // Already loaded
            
            const response = await fetch(DATA_FILE);
            allDataByYear = await response.json();
            
            // Convert hierarchical structure to flat array
            allRoutesFlat = [];
            Object.entries(allDataByYear).forEach(([year, routes]) => {
                Object.entries(routes).forEach(([routeId, routeData]) => {
                    // Convert new structure to old structure for compatibility
                    const route = {
                        source: routeData.source,
                        destination: routeData.destination,
                        via_city: routeData.via_city,
                        flows: routeData.flow,
                        quantity: routeData.quantity,
                        is_international: routeData.is_international,
                        flow_type: routeData.flow_type,
                        // path: routeData.path,  // Will be added later with OSRM
                        
                        // Convert commodity structure
                        commodities: {},
                        by_commodity: {},
                        
                        // Store all years this route appears in
                        years: [parseInt(year)],
                        
                        // Transport modes from commodity data
                        transport_modes: {},
                        by_transport: {},
                        
                        // Store by_year for filtering
                        by_year: {}
                    };
                    
                    // Extract commodities and their transports
                    Object.entries(routeData.commodity || {}).forEach(([commName, commData]) => {
                        route.commodities[commName] = commData.quantity || 0;
                        
                        // Calculate total flows for this commodity (sum of all transport flows)
                        let commodityFlows = 0;
                        Object.entries(commData.transport || {}).forEach(([transName, transData]) => {
                            commodityFlows += transData.flow || 0;
                        });
                        
                        route.by_commodity[commName] = {
                            flows: commodityFlows,  // Real flow count
                            quantity: commData.quantity || 0,  // Quantity
                            transport_modes: commData.transport || {},
                            category: commData.category
                        };
                        
                        // Aggregate transport modes
                        const totalCommodityQuantity = commData.quantity || 0;
                        
                        Object.entries(commData.transport || {}).forEach(([transName, transData]) => {
                            if (!route.transport_modes[transName]) {
                                route.transport_modes[transName] = 0;
                            }
                            route.transport_modes[transName] += transData.flow || 0;
                            
                            if (!route.by_transport[transName]) {
                                route.by_transport[transName] = {
                                    flows: 0,
                                    quantity: 0,
                                    commodities: {},
                                    years: []
                                };
                            }
                            route.by_transport[transName].flows += transData.flow || 0;
                            
                            // FIX: Distribute quantity by flow proportion to avoid double-counting
                            // If a commodity uses multiple transports, split quantity by flow ratio
                            const transportQuantity = commodityFlows > 0 
                                ? (transData.flow / commodityFlows) * totalCommodityQuantity 
                                : (transData.quantity || 0);
                            
                            route.by_transport[transName].quantity += transportQuantity;
                            route.by_transport[transName].commodities[commName] = (route.by_transport[transName].commodities[commName] || 0) + transportQuantity;
                            
                            if (!route.by_transport[transName].years.includes(parseInt(year))) {
                                route.by_transport[transName].years.push(parseInt(year));
                            }
                        });
                    });
                    
                    // Get main transport mode
                    if (Object.keys(route.transport_modes).length > 0) {
                        route.main_transport = Object.entries(route.transport_modes)
                            .reduce((a, b) => a[1] > b[1] ? a : b)[0];
                    }
                    
                    // Store year-specific data
                    route.by_year[year] = {
                        flows: routeData.flow,
                        quantity: routeData.quantity,
                        commodities: {},
                        commodities_flows: {},  // NEW: separate flows for commodities
                        transport_modes: {}
                    };
                    
                    Object.entries(routeData.commodity || {}).forEach(([commName, commData]) => {
                        // Store quantity
                        route.by_year[year].commodities[commName] = commData.quantity || 0;
                        
                        // Calculate and store flows for this commodity
                        let commFlows = 0;
                        Object.entries(commData.transport || {}).forEach(([transName, transData]) => {
                            commFlows += transData.flow || 0;
                            
                            if (!route.by_year[year].transport_modes[transName]) {
                                route.by_year[year].transport_modes[transName] = 0;
                            }
                            route.by_year[year].transport_modes[transName] += transData.flow || 0;
                        });
                        
                        route.by_year[year].commodities_flows[commName] = commFlows;
                    });
                    
                    // Check if this route already exists (same source/dest/via_city but different year)
                    const existing = allRoutesFlat.find(r => 
                        r.source.name === route.source.name &&
                        r.destination.name === route.destination.name &&
                        (r.via_city?.name || null) === (route.via_city?.name || null)
                    );
                    
                    if (existing) {
                        // Merge with existing route
                        existing.flows += route.flows;
                        existing.quantity += route.quantity;
                        existing.years.push(parseInt(year));
                        existing.years = [...new Set(existing.years)].sort();
                        
                        // Merge commodities
                        Object.entries(route.commodities).forEach(([comm, qty]) => {
                            existing.commodities[comm] = (existing.commodities[comm] || 0) + qty;
                        });
                        
                        // Merge transport modes
                        Object.entries(route.transport_modes).forEach(([trans, count]) => {
                            existing.transport_modes[trans] = (existing.transport_modes[trans] || 0) + count;
                        });
                        
                        // Merge by_year
                        existing.by_year[year] = route.by_year[year];
                        
                        // Merge by_commodity (keep flows and quantity separate)
                        Object.entries(route.by_commodity).forEach(([comm, data]) => {
                            if (!existing.by_commodity[comm]) {
                                existing.by_commodity[comm] = {
                                    flows: data.flows || 0,
                                    quantity: data.quantity || 0,
                                    transport_modes: data.transport_modes || {},
                                    category: data.category
                                };
                            } else {
                                existing.by_commodity[comm].flows += (data.flows || 0);
                                existing.by_commodity[comm].quantity += (data.quantity || 0);
                            }
                        });
                        
                        // Merge by_transport
                        Object.entries(route.by_transport).forEach(([trans, data]) => {
                            if (!existing.by_transport[trans]) {
                                existing.by_transport[trans] = data;
                            } else {
                                existing.by_transport[trans].flows += data.flows;
                                existing.by_transport[trans].quantity += data.quantity;
                                existing.by_transport[trans].years = [...new Set([...existing.by_transport[trans].years, ...data.years])].sort();
                                
                                // Merge commodities within this transport
                                Object.entries(data.commodities || {}).forEach(([comm, qty]) => {
                                    existing.by_transport[trans].commodities[comm] = 
                                        (existing.by_transport[trans].commodities[comm] || 0) + qty;
                                });
                            }
                        });
                    } else {
                        allRoutesFlat.push(route);
                    }
                });
            });
            
            console.log(`Loaded ${allRoutesFlat.length} unique routes from ${Object.keys(allDataByYear).length} years`);
            return allRoutesFlat;
        }

        /**
         * Generate heatmap data from routes by aggregating to grid
         * Grid size: 0.5 degrees (approximately 55km at equator)
         */
        function generateHeatmapFromRoutes(routes) {
            const gridSize = 0.5;
            const gridMap = new Map();
            
            // Helper function to round coordinate to grid
            const roundToGrid = (coord) => Math.round(coord / gridSize) * gridSize;
            
            // Aggregate all source and destination points
            routes.forEach(route => {
                // Add source point
                if (route.source && route.source.coordinates) {
                    const [lon, lat] = route.source.coordinates;
                    const gridKey = `${roundToGrid(lon)},${roundToGrid(lat)}`;
                    
                    if (!gridMap.has(gridKey)) {
                        gridMap.set(gridKey, {
                            coordinates: [roundToGrid(lon), roundToGrid(lat)],
                            weight: 0,
                            quantity: 0,
                            type: 'source'
                        });
                    }
                    const grid = gridMap.get(gridKey);
                    grid.weight += route.flows || 1;
                    grid.quantity += route.quantity || 0;
                }
                
                // Add destination point
                if (route.destination && route.destination.coordinates) {
                    const [lon, lat] = route.destination.coordinates;
                    const gridKey = `${roundToGrid(lon)},${roundToGrid(lat)}`;
                    
                    if (!gridMap.has(gridKey)) {
                        gridMap.set(gridKey, {
                            coordinates: [roundToGrid(lon), roundToGrid(lat)],
                            weight: 0,
                            quantity: 0,
                            type: 'destination'
                        });
                    }
                    const grid = gridMap.get(gridKey);
                    grid.weight += route.flows || 1;
                    grid.quantity += route.quantity || 0;
                }
            });
            
            return Array.from(gridMap.values());
        }

        // Filter data based on source type (client-side)
        function getFilteredDataBySource(source) {
            if (!allRoutesFlat || allRoutesFlat.length === 0) return [];
            
            if (source === 'heatmap') {
                // Generate heatmap from all data dynamically
                return generateHeatmapFromRoutes(allRoutesFlat);
            } else if (source === 'all') {
                return allRoutesFlat;
            } else if (source === 'major') {
                return allRoutesFlat.filter(d => (d.flows || 0) >= 10);
            } else if (source === 'top100') {
                const sorted = [...allRoutesFlat].sort((a, b) => (b.flows || 0) - (a.flows || 0));
                return sorted.slice(0, 100);
            }
            
            return allRoutesFlat;
        }

        function initDeckGL() {
            deckgl = new DeckGL({
                container: 'map',
                mapStyle: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
                initialViewState: {
                    longitude: 3,
                    latitude: 9,
                    zoom: 4.8,
                    pitch: 35,
                    bearing: 0
                },
                controller: true,
                layers: []
            });
        }

        async function switchDataSource(source) {
            // Show loading
            const loadingEl = document.getElementById('loading');
            loadingEl.style.display = 'block';
            loadingEl.querySelector('.loading-text').textContent = 'Filtering data...';
            loadingEl.querySelector('.loading-subtext').textContent = `Preparing ${source} routes`;

            try {
                // Load all data if not yet loaded
                if (!allRoutesFlat || allRoutesFlat.length === 0) {
                    loadingEl.querySelector('.loading-text').textContent = 'Loading data...';
                    loadingEl.querySelector('.loading-subtext').textContent = 'Loading hierarchical data...';
                    await loadAllData();
                }

                if (source === 'heatmap') {
                    loadingEl.querySelector('.loading-text').textContent = 'Generating heatmap...';
                    loadingEl.querySelector('.loading-subtext').textContent = 'Aggregating to grid';
                }

                currentDataSource = source;
                filterAndUpdate();

                loadingEl.style.display = 'none';

            } catch (error) {
                console.error('Error switching data:', error);
                loadingEl.querySelector('.loading-text').textContent = '❌ Error loading data';
            }
        }

        async function switchToCommodity(commodity) {
            // Don't switch data source, just trigger filtering
            // This allows filtering commodities within current data source (including rural-urban data)
            filterAndUpdate();
        }

        function switchColorMode(mode) {
            colorMode = mode;
            
            // Always show Rural-Urban and Trade Type filters (regardless of color mode)
                document.getElementById('ruralUrbanFilterGroup').style.display = 'block';
            document.getElementById('tradeTypeFilterGroup').style.display = 'block';
            
            // Toggle legends based on color mode
            if (mode === 'rural_urban') {
                document.getElementById('legendRuralUrban').style.display = 'block';
                document.getElementById('legendInternational').style.display = 'none';
                document.getElementById('legendSourceDest').style.display = 'none';
            } else if (mode === 'source_destination') {
                document.getElementById('legendRuralUrban').style.display = 'none';
                document.getElementById('legendInternational').style.display = 'none';
                document.getElementById('legendSourceDest').style.display = 'block';
            } else if (mode === 'international') {
                document.getElementById('legendRuralUrban').style.display = 'none';
                document.getElementById('legendInternational').style.display = 'block';
                document.getElementById('legendSourceDest').style.display = 'none';
            }
            
            // Refresh visualization with new colors
            filterAndUpdate();
        }

        /**
         * Get precise display data for a route based on current filters
         * Uses by_year, by_transport, by_commodity for accurate filtering
         */
        function getRouteDisplayData(route, filters) {
            // UPDATED for multi-select: filters now contain arrays
            const { year, commodity, transport } = filters;
            
            // Start with full route data
            let displayData = {
                flows: route.flows,
                quantity: route.quantity,
                commodities: route.commodities,
                years: route.years,
                transport_modes: route.transport_modes,
                main_transport: route.main_transport
            };

            // Apply year filter using by_year breakdown (supports multiple years)
            if (year && !year.includes('all') && year.length > 0 && route.by_year) {
                displayData.flows = 0;
                displayData.quantity = 0;
                displayData.commodities = {};
                displayData.transport_modes = {};
                displayData.years = [];
                
                year.forEach(y => {
                    const yearData = route.by_year[y];
                    if (yearData) {
                        displayData.flows += yearData.flows || 0;
                        displayData.quantity += yearData.quantity || 0;
                        displayData.years.push(y);
                        
                        // Merge commodities
                        if (yearData.commodities) {
                            Object.entries(yearData.commodities).forEach(([comm, qty]) => {
                                displayData.commodities[comm] = (displayData.commodities[comm] || 0) + qty;
                            });
                        }
                        
                        // Merge transport modes
                        if (yearData.transport_modes) {
                            Object.entries(yearData.transport_modes).forEach(([trans, flows]) => {
                                displayData.transport_modes[trans] = (displayData.transport_modes[trans] || 0) + flows;
                            });
                        }
                    }
                });
                
                if (displayData.years.length === 0) return null; // No matching years
                
                // Update main transport
                const modes = Object.entries(displayData.transport_modes);
                if (modes.length > 0) {
                    displayData.main_transport = modes.reduce((a, b) => a[1] > b[1] ? a : b)[0];
                }
            }

            // Apply transport filter (supports multiple transports)
            if (transport && !transport.includes('all') && transport.length > 0 && route.by_transport) {
                let hasMatchingTransport = false;
                displayData.flows = 0;
                displayData.quantity = 0;
                displayData.commodities = {};
                const allTransportYears = [];
                
                transport.forEach(trans => {
                    const transportData = route.by_transport[trans];
                    if (transportData) {
                        hasMatchingTransport = true;
                        displayData.flows += transportData.flows || 0;
                        displayData.quantity += transportData.quantity || 0;
                        
                        // Merge commodities
                        if (transportData.commodities) {
                            Object.entries(transportData.commodities).forEach(([comm, qty]) => {
                                displayData.commodities[comm] = (displayData.commodities[comm] || 0) + qty;
                            });
                        }
                        
                        // Collect years
                        if (transportData.years) {
                            allTransportYears.push(...transportData.years);
                        }
                    }
                });
                
                if (!hasMatchingTransport) return null; // Route doesn't use any selected transport
                
                displayData.years = [...new Set(allTransportYears)];
                displayData.main_transport = transport[0]; // Use first selected transport
            }

            // Apply commodity filter (supports multiple commodities)
            if (commodity && !commodity.includes('all') && commodity.length > 0 && route.by_commodity) {
                let hasMatchingCommodity = false;
                displayData.flows = 0;
                displayData.quantity = 0;
                displayData.commodities = {};
                
                commodity.forEach(comm => {
                    const targetCommodity = COMMODITY_MAP[comm];
                    const commodityData = route.by_commodity[targetCommodity];
                    
                    if (commodityData) {
                        hasMatchingCommodity = true;
                        displayData.flows += commodityData.flows || 0;
                        displayData.quantity += commodityData.quantity || 0;
                        displayData.commodities[targetCommodity] = commodityData.quantity || 0;
                    }
                });
                
                if (!hasMatchingCommodity) return null; // Route doesn't transport any selected commodity
            }

            return displayData;
        }

        /**
         * Update filter options based on current selections (SIMPLIFIED LOGIC)
         * Each filter shows data available if you select that option (independent of its own current value)
         */
        function updateFilterOptions(currentFilters) {
            // Safety check - ensure DOM elements exist
            if (!document.querySelector('.commodity-card') || !document.querySelector('.filter-bar-item')) {
                console.log('DOM not ready for filter constraints, skipping...');
                return;
            }
            
            // Get base routes based on currentDataSource (Route Filter)
            let baseRoutes = allRoutesFlat;
            if (currentDataSource === 'major') {
                baseRoutes = allRoutesFlat.filter(d => (d.flows || 0) >= 10);
            } else if (currentDataSource === 'top100') {
                const sorted = [...allRoutesFlat].sort((a, b) => (b.flows || 0) - (a.flows || 0));
                baseRoutes = sorted.slice(0, 100);
            }
            
            // Calculate available options for each filter (SIMPLIFIED)
            const availableOptions = calculateAvailableOptions(baseRoutes, currentFilters);
            
            // Update interactive filter UI
            updateInteractiveFilterOptions(availableOptions, currentFilters);
        }

        /**
         * Calculate available options - SIMPLIFIED LOGIC
         * 
         * NEW FILTERING PRINCIPLE:
         * - When calculating options for a filter, EXCLUDE that filter's own condition
         * - This means: selecting "Rice" keeps Rice's value unchanged, only affects other filters
         * 
         * Example: If user selects "Rice" and "2015":
         * - Commodity filter: Shows ALL commodities' quantities for 2015 (Rice stays highlighted)
         * - Year filter: Shows ALL years' quantities for Rice (2015 stays highlighted)
         * - Transport filter: Shows transports used for Rice in 2015
         * 
         * This is much simpler and more intuitive than the old logic!
         */
        function calculateAvailableOptions(routes, currentFilters) {
            const { year, commodity, transport, ruralUrban, tradeType, viaCity } = currentFilters;
            
            const options = {
                years: new Map(),
                commodities: new Map(),
                transports: new Map(),
                ruralUrban: new Map(),
                tradeTypes: new Map(),
                viaCities: new Map()
            };
            
            // Helper: Apply filters EXCEPT the specified filterType (supports multi-select)
            function getFilteredRoutes(excludeFilter) {
                return routes.filter(route => {
                    // Apply commodity filter (unless excluded) - supports multiple selections
                    if (excludeFilter !== 'commodity' && !commodity.includes('all')) {
                        const hasMatchingCommodity = commodity.some(comm => {
                            const targetCommodity = COMMODITY_MAP[comm];
                            return route.by_commodity && route.by_commodity[targetCommodity];
                        });
                        if (!hasMatchingCommodity) return false;
                    }
                    
                    // Apply transport filter (unless excluded) - supports multiple selections
                    if (excludeFilter !== 'transport' && !transport.includes('all')) {
                        const hasMatchingTransport = transport.some(trans => {
                            return route.by_transport && route.by_transport[trans];
                        });
                        if (!hasMatchingTransport) return false;
                    }
                    
                    // Apply year filter (unless excluded) - supports multiple selections
                    if (excludeFilter !== 'year' && !year.includes('all')) {
                        const hasMatchingYear = year.some(y => {
                            return route.by_year && route.by_year[y];
                        });
                        if (!hasMatchingYear) return false;
                    }
                    
                    // Apply rural-urban filter (unless excluded) - supports multiple selections
                    if (excludeFilter !== 'ruralUrban' && !ruralUrban.includes('all')) {
                        if (!ruralUrban.includes(route.flow_type)) return false;
                    }
                    
                    // Apply trade type filter (unless excluded) - supports multiple selections
                    if (excludeFilter !== 'tradeType' && !tradeType.includes('all')) {
                        const routeTradeType = route.is_international ? 'international' : 'domestic';
                        if (!tradeType.includes(routeTradeType)) return false;
                    }
                    
                    // Apply via city filter (unless excluded) - supports multiple selections
                    if (excludeFilter !== 'viaCity' && !viaCity.includes('all') && viaCity.length > 0) {
                        // Check if route has a via_city and if it's in the selected list
                        if (!route.via_city || !route.via_city.name) {
                            // Route has no via_city, check if 'Direct' is selected
                            if (!viaCity.includes('Direct')) return false;
                        } else {
                            // Route has via_city, check if it's in the selected list
                            if (!viaCity.includes(route.via_city.name)) return false;
                        }
                    }
                    
                    return true;
                });
            }
            
            // Calculate commodities (exclude commodity filter)
            const routesForCommodities = getFilteredRoutes('commodity');
            routesForCommodities.forEach(route => {
                // Get commodity data based on active filters
                let commoditySource = null;
                
                // Priority 1: Transport-specific data (if transport is selected)
                if (!transport.includes('all') && route.by_transport) {
                    // Merge commodities from all selected transports
                    commoditySource = {};
                    transport.forEach(trans => {
                        if (route.by_transport[trans] && route.by_transport[trans].commodities) {
                            Object.entries(route.by_transport[trans].commodities).forEach(([comm, qty]) => {
                                commoditySource[comm] = (commoditySource[comm] || 0) + qty;
                            });
                        }
                    });
                }
                // Priority 2: Year-specific data (if year is selected)
                else if (!year.includes('all') && route.by_year) {
                    commoditySource = {};
                    year.forEach(y => {
                        if (route.by_year[y] && route.by_year[y].commodities) {
                            Object.entries(route.by_year[y].commodities).forEach(([comm, qty]) => {
                                commoditySource[comm] = (commoditySource[comm] || 0) + qty;
                    });
                }
            });
                } 
                // Priority 3: Overall data
                else {
                    commoditySource = {};
                    if (route.by_commodity) {
                        Object.entries(route.by_commodity).forEach(([comm, data]) => {
                            commoditySource[comm] = data.quantity || 0;
                        });
                    }
                }
                
                // Add to options
                Object.entries(commoditySource).forEach(([comm, quantity]) => {
                    const count = options.commodities.get(comm) || 0;
                    options.commodities.set(comm, count + quantity);
                });
            });
            
            // Calculate transports (exclude transport filter)
            const routesForTransports = getFilteredRoutes('transport');
            routesForTransports.forEach(route => {
                // Get transport data based on active filters
                let transportSource = null;
                
                // Priority 1: Year-specific data (if year is selected)
                if (!year.includes('all') && route.by_year) {
                    transportSource = {};
                    year.forEach(y => {
                        const yearData = route.by_year[y];
                        if (yearData && yearData.transport_modes) {
                    const yearQuantity = yearData.quantity || 0;
                            const totalYearFlows = Object.values(yearData.transport_modes).reduce((a, b) => a + b, 0);
                            
                            Object.entries(yearData.transport_modes).forEach(([trans, flows]) => {
                                // Distribute quantity by flow proportion (to avoid double-counting)
                                const quantity = totalYearFlows > 0 
                                    ? (flows / totalYearFlows) * yearQuantity 
                                    : 0;
                                transportSource[trans] = (transportSource[trans] || 0) + quantity;
                            });
                        }
                    });
                } 
                // Priority 2: Commodity-specific data (if commodity is selected)
                else if (!commodity.includes('all') && route.by_commodity) {
                    transportSource = {};
                    commodity.forEach(comm => {
                        const targetCommodity = COMMODITY_MAP[comm];
                        const commodityData = route.by_commodity[targetCommodity];
                        
                        if (commodityData) {
                            const commodityQuantity = commodityData.quantity || 0;
                            
                            if (commodityData.transport_modes) {
                                // Calculate total flows for this commodity
                                let totalCommodityFlows = 0;
                                Object.entries(commodityData.transport_modes).forEach(([trans, transData]) => {
                                    const flow = typeof transData === 'object' ? (transData.flow || 0) : transData;
                                    totalCommodityFlows += flow;
                                });
                                
                                // Distribute quantity by flow proportion
                                Object.entries(commodityData.transport_modes).forEach(([trans, transData]) => {
                                    const flow = typeof transData === 'object' ? (transData.flow || 0) : transData;
                                    const quantity = totalCommodityFlows > 0 
                                        ? (flow / totalCommodityFlows) * commodityQuantity 
                                        : 0;
                                    transportSource[trans] = (transportSource[trans] || 0) + quantity;
                                });
                            }
                        }
                    });
                }
                // Priority 3: Overall data
                else {
                    transportSource = {};
                    if (route.by_transport) {
                        Object.entries(route.by_transport).forEach(([trans, data]) => {
                            transportSource[trans] = data.quantity || 0;
                        });
                    }
                }
                
                // Add to options
                if (transportSource) {
                    Object.entries(transportSource).forEach(([trans, quantity]) => {
                        const count = options.transports.get(trans) || 0;
                        options.transports.set(trans, count + quantity);
                    });
                }
            });
            
            // Calculate years (exclude year filter)
            const routesForYears = getFilteredRoutes('year');
            routesForYears.forEach(route => {
                if (!route.by_year) return;
                
                Object.entries(route.by_year).forEach(([y, yearData]) => {
                    let quantity = yearData.quantity || 0;
                    
                    // If transport is selected, calculate based on selected transports proportion in this year
                    if (!transport.includes('all')) {
                        let transportQuantity = 0;
                        const totalFlows = Object.values(yearData.transport_modes || {}).reduce((a, b) => a + b, 0);
                        
                        transport.forEach(trans => {
                            if (yearData.transport_modes && yearData.transport_modes[trans]) {
                                const transportFlows = yearData.transport_modes[trans];
                                transportQuantity += totalFlows > 0 ? (transportFlows / totalFlows) * quantity : 0;
                            }
                        });
                        
                        quantity = transportQuantity;
                        if (quantity === 0) return; // No selected transport in this year
                    }
                    
                    // If commodity is selected, calculate proportion from selected commodities
                    if (!commodity.includes('all')) {
                        let commodityQuantity = 0;
                        
                        commodity.forEach(comm => {
                            const targetCommodity = COMMODITY_MAP[comm];
                            if (yearData.commodities && yearData.commodities[targetCommodity]) {
                                // If transport was also selected, approximate the intersection
                                if (!transport.includes('all')) {
                                    const totalCommodityQuantity = Object.values(yearData.commodities).reduce((a, b) => a + b, 0);
                                    const thisCommodityQuantity = yearData.commodities[targetCommodity];
                                    commodityQuantity += totalCommodityQuantity > 0 
                                        ? (thisCommodityQuantity / totalCommodityQuantity) * quantity 
                                        : 0;
                } else {
                                    commodityQuantity += yearData.commodities[targetCommodity];
                                }
                            }
                        });
                        
                        quantity = commodityQuantity;
                        if (quantity === 0) return; // No selected commodity in this year
                    }
                    
                    const count = options.years.get(y) || 0;
                    options.years.set(y, count + quantity);
                });
            });
            
            // Calculate rural-urban (exclude ruralUrban filter)
            const routesForRuralUrban = getFilteredRoutes('ruralUrban');
            routesForRuralUrban.forEach(route => {
                // Calculate quantity based on other active filters
                let quantityCount = route.quantity || 0;
                
                // Priority 1: If transport is selected, sum up selected transports
                if (!transport.includes('all') && route.by_transport) {
                    quantityCount = 0;
                    transport.forEach(trans => {
                        if (route.by_transport[trans]) {
                            let transQuantity = route.by_transport[trans].quantity || 0;
                            
                            // If commodity is also selected
                            if (!commodity.includes('all')) {
                                let commTransQuantity = 0;
                                commodity.forEach(comm => {
                                    const targetCommodity = COMMODITY_MAP[comm];
                                    const transportData = route.by_transport[trans];
                                    if (transportData.commodities && transportData.commodities[targetCommodity]) {
                                        commTransQuantity += transportData.commodities[targetCommodity];
                                    }
                                });
                                transQuantity = commTransQuantity;
                            }
                            quantityCount += transQuantity;
                        }
                    });
                    if (quantityCount === 0) return;
                }
                // Priority 2: If year is selected (and transport is not)
                else if (!year.includes('all') && route.by_year) {
                    quantityCount = 0;
                    year.forEach(y => {
                        const yearData = route.by_year[y];
                        if (yearData) {
                            let yearQuantity = yearData.quantity || 0;
                            
                            // If commodity is also selected
                            if (!commodity.includes('all')) {
                                let commYearQuantity = 0;
                                commodity.forEach(comm => {
                                    const targetCommodity = COMMODITY_MAP[comm];
                                    if (yearData.commodities && yearData.commodities[targetCommodity]) {
                                        commYearQuantity += yearData.commodities[targetCommodity];
                                    }
                                });
                                yearQuantity = commYearQuantity;
                            }
                            quantityCount += yearQuantity;
                        }
                    });
                    if (quantityCount === 0) return;
                }
                // Priority 3: If only commodity is selected
                else if (!commodity.includes('all') && route.by_commodity) {
                    quantityCount = 0;
                    commodity.forEach(comm => {
                        const targetCommodity = COMMODITY_MAP[comm];
                        if (route.by_commodity[targetCommodity]) {
                            quantityCount += route.by_commodity[targetCommodity].quantity || 0;
                        }
                    });
                    if (quantityCount === 0) return;
                }
                
                if (route.flow_type) {
                    const count = options.ruralUrban.get(route.flow_type) || 0;
                    options.ruralUrban.set(route.flow_type, count + quantityCount);
                }
            });
            
            // Calculate trade types (exclude tradeType filter) - same logic as rural-urban
            const routesForTradeTypes = getFilteredRoutes('tradeType');
            routesForTradeTypes.forEach(route => {
                // Calculate quantity based on other active filters
                let quantityCount = route.quantity || 0;
                
                // Priority 1: If transport is selected, sum up selected transports
                if (!transport.includes('all') && route.by_transport) {
                    quantityCount = 0;
                    transport.forEach(trans => {
                        if (route.by_transport[trans]) {
                            let transQuantity = route.by_transport[trans].quantity || 0;
                            
                            // If commodity is also selected
                            if (!commodity.includes('all')) {
                                let commTransQuantity = 0;
                                commodity.forEach(comm => {
                                    const targetCommodity = COMMODITY_MAP[comm];
                                    const transportData = route.by_transport[trans];
                                    if (transportData.commodities && transportData.commodities[targetCommodity]) {
                                        commTransQuantity += transportData.commodities[targetCommodity];
                                    }
                                });
                                transQuantity = commTransQuantity;
                            }
                            quantityCount += transQuantity;
                        }
                    });
                    if (quantityCount === 0) return;
                }
                // Priority 2: If year is selected (and transport is not)
                else if (!year.includes('all') && route.by_year) {
                    quantityCount = 0;
                    year.forEach(y => {
                        const yearData = route.by_year[y];
                        if (yearData) {
                            let yearQuantity = yearData.quantity || 0;
                            
                            // If commodity is also selected
                            if (!commodity.includes('all')) {
                                let commYearQuantity = 0;
                                commodity.forEach(comm => {
                                    const targetCommodity = COMMODITY_MAP[comm];
                                    if (yearData.commodities && yearData.commodities[targetCommodity]) {
                                        commYearQuantity += yearData.commodities[targetCommodity];
                                    }
                                });
                                yearQuantity = commYearQuantity;
                            }
                            quantityCount += yearQuantity;
                        }
                    });
                    if (quantityCount === 0) return;
                }
                // Priority 3: If only commodity is selected
                else if (!commodity.includes('all') && route.by_commodity) {
                    quantityCount = 0;
                    commodity.forEach(comm => {
                        const targetCommodity = COMMODITY_MAP[comm];
                        if (route.by_commodity[targetCommodity]) {
                            quantityCount += route.by_commodity[targetCommodity].quantity || 0;
                        }
                    });
                    if (quantityCount === 0) return;
                }
                
                const trade = route.is_international ? 'international' : 'domestic';
                const count = options.tradeTypes.get(trade) || 0;
                options.tradeTypes.set(trade, count + quantityCount);
            });
            
            // Calculate via cities (exclude viaCity filter)
            const routesForViaCities = getFilteredRoutes('viaCity');
            routesForViaCities.forEach(route => {
                // Calculate quantity based on other active filters (same as trade types)
                let quantityCount = route.quantity || 0;
                
                // Priority 1: If transport is selected, sum up selected transports
                if (!transport.includes('all') && route.by_transport) {
                    quantityCount = 0;
                    transport.forEach(trans => {
                        if (route.by_transport[trans]) {
                            let transQuantity = route.by_transport[trans].quantity || 0;
                            
                            // If commodity is also selected
                            if (!commodity.includes('all')) {
                                let commTransQuantity = 0;
                                commodity.forEach(comm => {
                                    const targetCommodity = COMMODITY_MAP[comm];
                                    const transportData = route.by_transport[trans];
                                    if (transportData.commodities && transportData.commodities[targetCommodity]) {
                                        commTransQuantity += transportData.commodities[targetCommodity];
                                    }
                                });
                                transQuantity = commTransQuantity;
                            }
                            quantityCount += transQuantity;
                        }
                    });
                    if (quantityCount === 0) return;
                }
                // Priority 2: If year is selected (and transport is not)
                else if (!year.includes('all') && route.by_year) {
                    quantityCount = 0;
                    year.forEach(y => {
                        const yearData = route.by_year[y];
                        if (yearData) {
                            let yearQuantity = yearData.quantity || 0;
                            
                            // If commodity is also selected
                            if (!commodity.includes('all')) {
                                let commYearQuantity = 0;
                                commodity.forEach(comm => {
                                    const targetCommodity = COMMODITY_MAP[comm];
                                    if (yearData.commodities && yearData.commodities[targetCommodity]) {
                                        commYearQuantity += yearData.commodities[targetCommodity];
                                    }
                                });
                                yearQuantity = commYearQuantity;
                            }
                            quantityCount += yearQuantity;
                        }
                    });
                    if (quantityCount === 0) return;
                }
                // Priority 3: If only commodity is selected
                else if (!commodity.includes('all') && route.by_commodity) {
                    quantityCount = 0;
                    commodity.forEach(comm => {
                        const targetCommodity = COMMODITY_MAP[comm];
                        if (route.by_commodity[targetCommodity]) {
                            quantityCount += route.by_commodity[targetCommodity].quantity || 0;
                        }
                    });
                    if (quantityCount === 0) return;
                }
                
                // Categorize by via_city
                const viaCityName = route.via_city && route.via_city.name ? route.via_city.name : 'Direct';
                const count = options.viaCities.get(viaCityName) || 0;
                options.viaCities.set(viaCityName, count + quantityCount);
            });
            
            return options;
        }

        /**
         * Update interactive filter options in the UI
         */
        function updateInteractiveFilterOptions(availableOptions, currentFilters) {
            // Regenerate commodity and transport options with updated data
            generateCommodityCards(availableOptions.commodities);
            generateTransportBars(availableOptions.transports);
            generateViaCityBars(availableOptions.viaCities);
            
            // Restore active state for current selections
            restoreActiveState(currentFilters);
            
            // Update year filter
            updateYearFilterOptions(availableOptions.years);
            
            // Update rural-urban filter
            updateRuralUrbanFilterOptions(availableOptions.ruralUrban);
            
            // Update trade type filter
            updateTradeTypeFilterOptions(availableOptions.tradeTypes);
            
            // Ensure Color Mode options are always available (not constrained by other filters)
            ensureColorModeAlwaysAvailable();
        }

        /**
         * Restore active state after regenerating filter options
         */
        function restoreActiveState(currentFilters) {
            const { commodity, transport, viaCity } = currentFilters;
            
            // Restore commodity active state (supports multi-select)
                const commodityCards = document.querySelectorAll('.commodity-card');
                commodityCards.forEach(card => {
                    const nameEl = card.querySelector('.commodity-name');
                    if (nameEl) {
                        const name = nameEl.textContent.trim();
                    
                    // Check if 'All' card
                    if (name === 'All') {
                        if (!commodity || commodity.length === 0 || commodity.includes('all')) {
                            card.classList.add('active');
                        } else {
                            card.classList.remove('active');
                        }
                    } else {
                        // Check if this commodity is in the selected array
                        let isSelected = false;
                        if (commodity && !commodity.includes('all')) {
                            commodity.forEach(comm => {
                                const dataName = COMMODITY_MAP[comm];
                                if (dataName === name) {
                                    isSelected = true;
                    }
                });
            }
            
                        if (isSelected) {
                            card.classList.add('active');
                        } else {
                            card.classList.remove('active');
                        }
                    }
                }
            });
            
            // Restore transport active state (supports multi-select)
                const transportBars = document.querySelectorAll('#transportBars .filter-bar-item');
                transportBars.forEach(bar => {
                    const labelEl = bar.querySelector('.filter-bar-label');
                if (labelEl) {
                    const label = labelEl.textContent.trim();
                    
                    // Check if 'All Modes' bar
                    if (label === 'All Modes') {
                        if (!transport || transport.length === 0 || transport.includes('all')) {
                        bar.classList.add('active');
                        } else {
                            bar.classList.remove('active');
                        }
                    } else {
                        // Check if this transport is in the selected array
                        const isSelected = transport && transport.length > 0 && !transport.includes('all') && transport.includes(label);
                        
                        if (isSelected) {
                            bar.classList.add('active');
                        } else {
                            bar.classList.remove('active');
                        }
                    }
                }
            });
            
            // Restore via city active state (supports multi-select)
            const viaCityBars = document.querySelectorAll('#viaCityBars .filter-bar-item');
            viaCityBars.forEach(bar => {
                const labelEl = bar.querySelector('.filter-bar-label');
                if (labelEl) {
                    const label = labelEl.textContent.trim();
                    
                    // Check if 'All Routes' bar
                    if (label === 'All Routes') {
                        if (!viaCity || viaCity.length === 0 || viaCity.includes('all')) {
                            bar.classList.add('active');
                        } else {
                            bar.classList.remove('active');
                        }
                    } else {
                        // Remove icons from label for comparison
                        const cleanLabel = label.replace(/^[→⤴]\s*/, '');
                        const isSelected = viaCity && viaCity.length > 0 && !viaCity.includes('all') && viaCity.includes(cleanLabel);
                        
                        if (isSelected) {
                            bar.classList.add('active');
                        } else {
                            bar.classList.remove('active');
                        }
                    }
                }
            });
        }

        /**
         * Generate a stacked bar chart
         * @param {string} containerId - ID of the container for the bar chart
         * @param {string} legendId - ID of the container for the legend
         * @param {Map} dataMap - Map of values for the bar chart (key -> count)
         * @param {Map} allDataMap - Map of all available values for the legend (key -> count)
         * @param {Object} colorMap - Map of colors (key -> color)
         * @param {Object} labelMap - Map of labels (key -> label), optional
         * @param {string} selectedKey - Currently selected key
         * @param {Function} onSelect - Callback when segment is clicked
         * @param {boolean} sortByKey - If true, sort by key (e.g., years), otherwise by value
         */
        function generateStackedBarChart(containerId, legendId, dataMap, allDataMap, colorMap, labelMap, selectedKeys, onSelect, sortByKey = false) {
            const container = document.getElementById(containerId);
            
            if (!container) return;
            
            // Calculate total from bar chart data
            const total = Array.from(dataMap.values()).reduce((a, b) => a + b, 0);
            if (total === 0) return;
            
            // Clear existing content
            container.innerHTML = '';
            
            // selectedKeys is now an array for multi-select support
            const selectedArray = Array.isArray(selectedKeys) ? selectedKeys : (selectedKeys ? [selectedKeys] : []);
            
            // Generate bar segments from dataMap
            const sortedEntries = sortByKey 
                ? Array.from(dataMap.entries()).sort((a, b) => a[0].localeCompare(b[0]))  // Sort by key (for years)
                : Array.from(dataMap.entries()).sort((a, b) => b[1] - a[1]);              // Sort by value (for others)
            
            sortedEntries.forEach(([key, value]) => {
                const percentage = (value / total) * 100;
                const color = colorMap[key] || '#999';
                const label = labelMap ? labelMap[key] : key;
                const isSelected = selectedArray.includes(key);
                
                // Get value from allDataMap for display
                const displayValue = allDataMap.get(key) || value;
                
                // Create bar segment - click toggles selection
                const segment = document.createElement('div');
                segment.className = `stacked-bar-segment ${isSelected ? 'selected' : ''}`;
                segment.style.width = `${percentage}%`;
                segment.style.backgroundColor = color;
                segment.onclick = () => {
                    // Toggle selection
                        onSelect(key);
                };
                
                // Add label with percentage if segment is wide enough
                if (percentage > 8) {
                    const labelEl = document.createElement('div');
                    labelEl.className = 'stacked-bar-label';
                    labelEl.innerHTML = `
                        <div class="stacked-bar-label-year">${label}</div>
                        <!-- <div class="stacked-bar-label-count">${formatCount(displayValue)}</div> -->
                        <div class="stacked-bar-label-count">${percentage.toFixed(1)}%</div>
                    `;
                    segment.appendChild(labelEl);
                } else if (percentage > 4) {
                    // For medium segments, show label and percentage only
                    const labelEl = document.createElement('div');
                    labelEl.className = 'stacked-bar-label';
                    labelEl.innerHTML = `
                        <div class="stacked-bar-label-year">${label}</div>
                        <div class="stacked-bar-label-count">${percentage.toFixed(0)}%</div>
                    `;
                    segment.appendChild(labelEl);
                } else if (percentage > 2) {
                    // For smaller segments, only show label
                    const labelEl = document.createElement('div');
                    labelEl.className = 'stacked-bar-label';
                    labelEl.innerHTML = `<div class="stacked-bar-label-year">${label}</div>`;
                    segment.appendChild(labelEl);
                }
                
                container.appendChild(segment);
            });
        }

        function updateYearFilterOptions(availableYears) {
            // Get selected years from global state
            const selectedYears = selectedFilters.years.length > 0 ? selectedFilters.years : [];
            
            generateStackedBarChart(
                'yearStackedBar',
                'yearLegend',
                availableYears,          // Filtered data for bar
                globalStats.years,       // All years for legend
                STACKED_BAR_COLORS,
                null, // Use keys as labels
                selectedYears,  // Pass array of selected years
                (year) => selectYearStat(null, year),
                true  // Sort by year (chronologically)
            );
        }


        function updateRuralUrbanFilterOptions(availableRuralUrban) {
            // Get selected rural-urban types from global state
            const selectedTypes = selectedFilters.ruralUrban.length > 0 ? selectedFilters.ruralUrban : [];
            
            generateStackedBarChart(
                'ruralUrbanStackedBar',
                'ruralUrbanLegend',
                availableRuralUrban,        // Filtered data for bar
                globalStats.ruralUrban,     // All types for legend
                STACKED_BAR_COLORS,
                FLOW_PATTERN_LABELS,
                selectedTypes,  // Pass array of selected types
                (type) => selectRuralUrbanStat(null, type)
            );
        }

        function updateTradeTypeFilterOptions(availableTradeTypes) {
            // Get selected trade types from global state
            const selectedTypes = selectedFilters.tradeTypes.length > 0 ? selectedFilters.tradeTypes : [];
            
            generateStackedBarChart(
                'tradeTypeStackedBar',
                'tradeTypeLegend',
                availableTradeTypes,        // Filtered data for bar
                globalStats.tradeTypes,     // All types for legend
                STACKED_BAR_COLORS,
                TRADE_TYPE_LABELS,
                selectedTypes,  // Pass array of selected types
                (type) => selectTradeTypeStat(null, type)
            );
        }

        function updateRouteFilterBars(routeFilterStats) {
            // Get all route filter stat bars
            const routeFilterBars = document.querySelectorAll('.stats-chart .stat-bar');
            const routeBars = Array.from(routeFilterBars).filter(bar => 
                bar.getAttribute('onclick')?.includes('selectRouteFilterStat')
            );
            
            const maxCount = Math.max(...Object.values(routeFilterStats));
            
            routeBars.forEach(bar => {
                if (!bar) return;
                
                const labelEl = bar.querySelector('.stat-bar-label');
                if (!labelEl) return;
                
                const label = labelEl.textContent.trim();
                let filterType = label.toLowerCase();
                
                if (label === 'All') {
                    bar.style.height = '100%';
                    bar.style.opacity = '1';
                    bar.style.pointerEvents = 'auto';
                } else if (label === 'Top100') {
                    filterType = 'top100';
                    const count = routeFilterStats[filterType];
                    const percentage = Math.round((count / maxCount) * 100);
                    bar.style.height = `${Math.max(percentage, 5)}%`; // Minimum 5% for visibility
                    bar.style.opacity = '1';
                    bar.style.pointerEvents = 'auto';
                } else if (routeFilterStats[filterType]) {
                    const count = routeFilterStats[filterType];
                    const percentage = Math.round((count / maxCount) * 100);
                    bar.style.height = `${percentage}%`;
                    bar.style.opacity = '1';
                    bar.style.pointerEvents = 'auto';
                }
            });
        }

        function updateColorModeBars(ruralUrbanStats, tradeTypeStats) {
            const colorModeBars = document.querySelectorAll('.color-mode-bar');
            
            colorModeBars.forEach(bar => {
                if (!bar) return;
                
                const mode = bar.getAttribute('data-mode');
                const barFill = bar.querySelector('.bar-fill');
                const barValue = bar.querySelector('.bar-value');
                
                if (!barFill || !barValue) return;
                
                if (mode === 'source_destination') {
                    // Source-Destination mode shows all data
                    barFill.style.width = '100%';
                    barValue.textContent = 'Default';
                } else if (mode === 'rural_urban') {
                    // Rural-Urban mode shows dominant rural-urban flow
                    const total = Array.from(ruralUrbanStats.values()).reduce((a, b) => a + b, 0);
                    const ruralToUrban = ruralUrbanStats.get('rural_to_urban') || 0;
                    if (total > 0) {
                        const percentage = Math.round((ruralToUrban / total) * 100);
                        barFill.style.width = `${percentage}%`;
                        barValue.textContent = `R→U ${percentage}%`;
                    }
                } else if (mode === 'international') {
                    // International mode shows international percentage
                    const total = Array.from(tradeTypeStats.values()).reduce((a, b) => a + b, 0);
                    const international = tradeTypeStats.get('international') || 0;
                    if (total > 0) {
                        const percentage = Math.round((international / total) * 100);
                        barFill.style.width = `${percentage}%`;
                        barValue.textContent = `Intl ${percentage}%`;
                    }
                }
            });
        }

        function formatCount(count) {
            if (count >= 1000) {
                return (count / 1000).toFixed(1) + 'K';
            }
            return count.toString();
        }

        function formatQuantity(num) {
            if (num >= 1000000000) {
                return (num / 1000000000).toFixed(1) + 'B';
            } else if (num >= 1000000) {
                return (num / 1000000).toFixed(0) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(0) + 'K';
            }
            return Math.round(num).toString();
        }

        /**
         * Ensure Color Mode options are always available (not constrained by other filters)
         */
        function ensureColorModeAlwaysAvailable() {
            const allControlGroups = document.querySelectorAll('.control-group');
            allControlGroups.forEach(group => {
                const label = group.querySelector('label');
                if (label && label.textContent.trim() === 'Color Mode') {
                    const colorModeBars = group.querySelectorAll('.filter-bar-item');
                    colorModeBars.forEach(bar => {
                        bar.style.opacity = '1';
                        bar.style.pointerEvents = 'auto';
                    });
                }
            });
        }

        // Global state for multi-select filters
        let selectedFilters = {
            years: [],
            commodities: [],
            transports: [],
            ruralUrban: [],
            tradeTypes: [],
            viaCities: []  // Add via_city filter
        };

        function filterAndUpdate() {
            // Get values from global state (multi-select)
            const year = selectedFilters.years.length > 0 ? selectedFilters.years : ['all'];
            const commodity = selectedFilters.commodities.length > 0 ? selectedFilters.commodities : ['all'];
            const transport = selectedFilters.transports.length > 0 ? selectedFilters.transports : ['all'];
            const ruralUrban = selectedFilters.ruralUrban.length > 0 ? selectedFilters.ruralUrban : ['all'];
            const tradeType = selectedFilters.tradeTypes.length > 0 ? selectedFilters.tradeTypes : ['all'];
            const viaCity = selectedFilters.viaCities.length > 0 ? selectedFilters.viaCities : ['all'];
            
            // Update filter options based on current selections (constraints)
            updateFilterOptions({ year, commodity, transport, ruralUrban, tradeType, viaCity });
            
            if (currentDataSource === 'heatmap') {
                // For heatmap: filter routes first, then generate heatmap from filtered data
                const filters = { year, commodity, transport };
                
                let routesToAggregate = allRoutesFlat.map(route => {
                    // Apply rural-urban filter (works in all color modes) - supports multiple selections
                    if (!ruralUrban.includes('all') && ruralUrban.length > 0) {
                        if (!ruralUrban.includes(route.flow_type)) {
                        return null;
                        }
                    }
                    
                    // Apply international-domestic filter (works in all color modes) - supports multiple selections
                    if (!tradeType.includes('all') && tradeType.length > 0) {
                        const routeTradeType = route.is_international ? 'international' : 'domestic';
                        if (!tradeType.includes(routeTradeType)) {
                            return null;
                        }
                    }
                    
                    // Apply via city filter - supports multiple selections
                    if (!viaCity.includes('all') && viaCity.length > 0) {
                        const routeViaCity = route.via_city && route.via_city.name ? route.via_city.name : 'Direct';
                        if (!viaCity.includes(routeViaCity)) {
                            return null;
                        }
                    }
                    
                    // Get precise display data based on filters
                    const displayData = getRouteDisplayData(route, filters);
                    if (!displayData) return null; // Route doesn't match filters
                    
                    // Attach display data to route for aggregation
                    return {
                        ...route,
                        _displayData: displayData
                    };
                }).filter(r => r !== null);
                
                // Store filtered routes info for stats (before aggregation)
                window.heatmapSourceRoutes = routesToAggregate;
                
                // Generate heatmap from filtered routes
                filteredRoutes = generateHeatmapFromRoutes(routesToAggregate);
            } else {
                // For other modes: standard route filtering
                let data = getFilteredDataBySource(currentDataSource);
                const filters = { year, commodity, transport };
                
                filteredRoutes = data.map(route => {
                    // Apply rural-urban filter (works in all color modes) - supports multiple selections
                    if (!ruralUrban.includes('all') && ruralUrban.length > 0) {
                        if (!ruralUrban.includes(route.flow_type)) {
                        return null;
                        }
                    }
                    
                    // Apply international-domestic filter (works in all color modes) - supports multiple selections
                    if (!tradeType.includes('all') && tradeType.length > 0) {
                        const routeTradeType = route.is_international ? 'international' : 'domestic';
                        if (!tradeType.includes(routeTradeType)) {
                            return null;
                        }
                    }
                    
                    // Apply via city filter - supports multiple selections
                    if (!viaCity.includes('all') && viaCity.length > 0) {
                        const routeViaCity = route.via_city && route.via_city.name ? route.via_city.name : 'Direct';
                        if (!viaCity.includes(routeViaCity)) {
                            return null;
                        }
                    }
                    
                    // Get precise display data based on filters
                    const displayData = getRouteDisplayData(route, filters);
                    if (!displayData) return null; // Route doesn't match filters
                    
                    // Attach display data to route for use in visualization
                    return {
                        ...route,
                        _displayData: displayData
                    };
                }).filter(r => r !== null);
            }

            updateStats();
            updateVisualization();
        }

        function updateStats() {
            if (currentDataSource === 'heatmap') {
                // Update labels for heatmap mode
                document.getElementById('routesLabel').textContent = 'Routes';
                document.getElementById('distanceLabel').textContent = 'Grid Points';
                
                // Show stats from filtered routes (before aggregation to grid)
                const sourceRoutes = window.heatmapSourceRoutes || [];
                
                // Total routes used to generate heatmap
                document.getElementById('visibleRoutes').textContent = sourceRoutes.length.toLocaleString();
                
                // Total quantity from filtered routes
                const totalQuantity = sourceRoutes.reduce((sum, r) => {
                    const quantity = r._displayData ? (r._displayData.quantity || 0) : (r.quantity || 0);
                    return sum + quantity;
                }, 0);
                document.getElementById('totalFlows').textContent = formatQuantity(totalQuantity);
                
                // International flows count
                const intlCount = sourceRoutes.filter(r => r.is_international).length;
                document.getElementById('intlFlows').textContent = intlCount.toLocaleString();
                
                // Grid points generated
                document.getElementById('avgDistance').textContent = filteredRoutes.length.toLocaleString();
                
                return;
            }
            
            // Reset labels for non-heatmap modes
            document.getElementById('routesLabel').textContent = 'Routes';
            document.getElementById('distanceLabel').textContent = 'Avg Distance';

            // Use precise quantity from _displayData
            const totalQuantity = filteredRoutes.reduce((sum, r) => {
                const quantity = r._displayData ? (r._displayData.quantity || 0) : (r.quantity || 0);
                return sum + quantity;
            }, 0);
            const totalFlows = filteredRoutes.reduce((sum, r) => {
                const flows = r._displayData ? r._displayData.flows : r.flows;
                return sum + (flows || 0);
            }, 0);
            const intlCount = filteredRoutes.filter(r => r.is_international).length;
            
            // Calculate average distance
            let totalDistance = 0;
            let count = 0;
            filteredRoutes.forEach(r => {
                if (r.source && r.destination && r.source.coordinates && r.destination.coordinates) {
                    const [lon1, lat1] = r.source.coordinates;
                    const [lon2, lat2] = r.destination.coordinates;
                    const dist = calculateDistance(lat1, lon1, lat2, lon2);
                    totalDistance += dist;
                    count++;
                }
            });
            const avgDist = count > 0 ? Math.round(totalDistance / count) : 0;

            document.getElementById('visibleRoutes').textContent = filteredRoutes.length.toLocaleString();
            document.getElementById('totalFlows').textContent = formatQuantity(totalQuantity);
            document.getElementById('intlFlows').textContent = intlCount.toLocaleString();
            document.getElementById('avgDistance').textContent = avgDist + ' km';
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        function getFlowTypeColor(route) {
            if (colorMode === 'rural_urban' && route.flow_type) {
                // Rural-Urban color scheme (legacy, for reference)
                const colors = {
                    'rural_to_urban': [46, 204, 113],    // Green - Rural supplies Urban
                    'urban_to_rural': [52, 152, 219],    // Blue - Urban supplies Rural
                    'rural_to_rural': [241, 196, 15],    // Yellow - Rural to Rural flows
                    'urban_to_urban': [155, 89, 182]     // Purple - Urban to Urban flows
                };
                return colors[route.flow_type] || [200, 200, 200];
            } else {
                // International-Domestic color scheme
                return route.is_international ? [229, 62, 62] : [49, 130, 206];
            }
        }

        // Get color based on location type (Urban = yellow, Rural = blue)
        function getLocationColor(isUrban) {
            if (isUrban) {
                return [251, 232, 25]; // #FBE819 Yellow for urban
            } else {
                return [42, 80, 234]; // #2A50EA Blue for rural
            }
        }

        // Get color based on point type (Source = green, Destination = red)
        function getPointTypeColor(isSource) {
            if (isSource) {
                return [16, 185, 129]; // #10b981 Green for source
            } else {
                return [239, 68, 68]; // #ef4444 Red for destination
            }
        }

        function updateVisualization() {
            if (!deckgl) return; // Ensure deckgl is initialized
            
            const arcWidth = parseFloat(document.getElementById('arcWidth').value);
            const showArcs = document.getElementById('showArcs').checked;
            const showPoints = document.getElementById('showPoints').checked;
            const showViaCity = document.getElementById('showViaCity').checked;

            const layers = [];

            if (currentDataSource === 'heatmap') {
                // Heatmap layer
                const heatmapLayer = new HeatmapLayer({
                    id: 'heatmap-layer',
                    data: filteredRoutes,
                    getPosition: d => d.coordinates,
                    getWeight: d => d.weight,
                    radiusPixels: 60,
                    intensity: 1,
                    threshold: 0.05
                });
                layers.push(heatmapLayer);

            } else if (showArcs) {
                // Separate routes with OSRM paths from those without
                const routesWithPaths = filteredRoutes.filter(r => r.path && r.path.length > 0);
                const routesWithoutPaths = filteredRoutes.filter(r => !r.path || r.path.length === 0);
                
                // PathLayer for routes with OSRM paths (real road routing)
                const pathLayer = new PathLayer({
                    id: 'path-layer',
                    data: routesWithPaths,
                    getPath: d => d.path,
                    getColor: d => {
                        // Check if this route should be highlighted
                        let isHighlighted = true;
                        
                        // Priority 1: Point selection
                        if (selectedPoint) {
                            if (selectedPoint.type === 'source') {
                                const srcCoords = d.source.coordinates;
                                isHighlighted = (
                                    srcCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                    srcCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                );
                            } else if (selectedPoint.type === 'destination') {
                                const destCoords = d.destination.coordinates;
                                isHighlighted = (
                                    destCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                    destCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                );
                            }
                        }
                        // Priority 2: Route selection
                        else if (selectedRoute) {
                            isHighlighted = (d.source.name === selectedRoute.source.name && 
                                           d.destination.name === selectedRoute.destination.name);
                        }
                        // Priority 3: Hover
                        else if (hoveredRoute) {
                            isHighlighted = (d.source.name === hoveredRoute.source.name && 
                                           d.destination.name === hoveredRoute.destination.name);
                        }
                        
                        if (colorMode === 'rural_urban') {
                            const color = getLocationColor(d.source.is_urban);
                            const alpha = isHighlighted ? 200 : 30;
                            return [color[0], color[1], color[2], alpha];
                        } else if (colorMode === 'source_destination') {
                            const color = [100, 180, 255]; // Blue for paths
                            const alpha = isHighlighted ? 200 : 40;
                            return [color[0], color[1], color[2], alpha];
                        } else {
                            const color = getFlowTypeColor(d);
                            const alpha = isHighlighted ? 255 : 40;
                            return [color[0], color[1], color[2], alpha];
                        }
                    },
                    getWidth: d => {
                        // Use quantity instead of flows for width
                        const quantity = d.quantity || d.flows || 1;
                        const baseWidth = Math.sqrt(quantity) * 0.15;  // Reduced from 0.5 to 0.15
                        let isHighlighted = false;
                        
                        if (selectedPoint) {
                            if (selectedPoint.type === 'source') {
                                const srcCoords = d.source.coordinates;
                                isHighlighted = (
                                    srcCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                    srcCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                );
                            } else if (selectedPoint.type === 'destination') {
                                const destCoords = d.destination.coordinates;
                                isHighlighted = (
                                    destCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                    destCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                );
                            }
                        } else if (selectedRoute) {
                            isHighlighted = (d.source.name === selectedRoute.source.name && 
                                           d.destination.name === selectedRoute.destination.name);
                        } else if (hoveredRoute) {
                            isHighlighted = (d.source.name === hoveredRoute.source.name && 
                                           d.destination.name === hoveredRoute.destination.name);
                        }
                        
                        return isHighlighted ? baseWidth * 3 : baseWidth;
                    },
                    widthMinPixels: 0.5,
                    widthMaxPixels: 10,
                    pickable: true,
                    onHover: info => {
                        if (info.object && !selectedRoute && !selectedPoint) {
                            hoveredRoute = info.object;
                        } else if (!info.object) {
                            hoveredRoute = null;
                        }
                    },
                    updateTriggers: {
                        getColor: [hoveredRoute, selectedRoute, selectedPoint, colorMode],
                        getWidth: [hoveredRoute, selectedRoute, selectedPoint]
                    }
                });
                layers.push(pathLayer);
                
                // Arc layer for routes without OSRM paths (fallback to straight lines)
                let arcData = routesWithoutPaths;
                
                // If showViaCity is enabled, create two-segment routes
                if (showViaCity) {
                    arcData = [];
                    routesWithoutPaths.forEach(route => {
                        if (route.via_city && route.via_city.coordinates) {
                            // First segment: source → via_city
                            arcData.push({
                                ...route,
                                _segment: 'first',
                                _targetPos: route.via_city.coordinates
                            });
                            // Second segment: via_city → destination
                            arcData.push({
                                ...route,
                                _segment: 'second',
                                _sourcePos: route.via_city.coordinates
                            });
                        } else {
                            // No via_city, keep as direct route
                            arcData.push(route);
                        }
                    });
                }
                
                const arcLayer = new ArcLayer({
                    id: 'arc-layer',
                    data: arcData,
                    getSourcePosition: d => d._sourcePos || d.source.coordinates,
                    getTargetPosition: d => d._targetPos || d.destination.coordinates,
                    getSourceColor: d => {
                        // Check if this route should be highlighted
                        let isHighlighted = true;
                        
                        // Priority 1: Point selection (compare by coordinates)
                        if (selectedPoint) {
                            if (selectedPoint.type === 'source') {
                                const srcCoords = d.source.coordinates;
                                isHighlighted = (
                                    srcCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                    srcCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                );
                            } else if (selectedPoint.type === 'destination') {
                                const destCoords = d.destination.coordinates;
                                isHighlighted = (
                                    destCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                    destCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                );
                            }
                        }
                        // Priority 2: Route selection
                        else if (selectedRoute) {
                            isHighlighted = (d.source.name === selectedRoute.source.name && 
                                           d.destination.name === selectedRoute.destination.name);
                        }
                        // Priority 3: Hover
                        else if (hoveredRoute) {
                            isHighlighted = (d.source.name === hoveredRoute.source.name && 
                                           d.destination.name === hoveredRoute.destination.name);
                        }
                        
                        if (colorMode === 'rural_urban') {
                            const color = getLocationColor(d.source.is_urban);
                            const alpha = isHighlighted ? 180 : 3;
                            return [color[0], color[1], color[2], alpha];
                        } else if (colorMode === 'source_destination') {
                            const color = getPointTypeColor(true);
                            const alpha = isHighlighted ? 200 : 5;
                            return [color[0], color[1], color[2], alpha];
                        } else {
                            const color = getFlowTypeColor(d);
                            const alpha = isHighlighted ? 255 : 5;
                            return [color[0], color[1], color[2], alpha];
                        }
                    },
                    getTargetColor: d => {
                        // Check if this route should be highlighted
                        let isHighlighted = true;
                        
                        // Priority 1: Point selection (compare by coordinates)
                        if (selectedPoint) {
                            if (selectedPoint.type === 'source') {
                                const srcCoords = d.source.coordinates;
                                isHighlighted = (
                                    srcCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                    srcCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                );
                            } else if (selectedPoint.type === 'destination') {
                                const destCoords = d.destination.coordinates;
                                isHighlighted = (
                                    destCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                    destCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                );
                            }
                        }
                        // Priority 2: Route selection
                        else if (selectedRoute) {
                            isHighlighted = (d.source.name === selectedRoute.source.name && 
                                           d.destination.name === selectedRoute.destination.name);
                        }
                        // Priority 3: Hover
                        else if (hoveredRoute) {
                            isHighlighted = (d.source.name === hoveredRoute.source.name && 
                                           d.destination.name === hoveredRoute.destination.name);
                        }
                        
                        if (colorMode === 'rural_urban') {
                            const color = getLocationColor(d.destination.is_urban);
                            const alpha = isHighlighted ? 60 : 2;
                            return [color[0], color[1], color[2], alpha];
                        } else if (colorMode === 'source_destination') {
                            const color = getPointTypeColor(false);
                            const alpha = isHighlighted ? 80 : 3;
                            return [color[0], color[1], color[2], alpha];
                        } else {
                            const color = getFlowTypeColor(d);
                            const alpha = isHighlighted ? 60 : 3;
                            return [color[0], color[1], color[2], alpha];
                        }
                    },
                    getWidth: d => {
                        // Use precise quantity from _displayData if available
                        const quantity = d._displayData ? (d._displayData.quantity || d._displayData.flows) : (d.quantity || d.flows || 1);
                        return Math.log(quantity + 1) * arcWidth * 0.6;  // Additional 0.6 multiplier to make lines thinner
                    },
                    pickable: true,
                    autoHighlight: false, // Disable auto-highlight, we handle it manually
                    onHover: handleHover,
                    onClick: handleClick,
                    updateTriggers: {
                        getWidth: arcWidth,  // Force recalculation when arcWidth changes
                        getSourceColor: [colorMode, hoveredRoute, selectedRoute, selectedPoint],  // Update when hover/select changes
                        getTargetColor: [colorMode, hoveredRoute, selectedRoute, selectedPoint]   // Update when hover/select changes
                    }
                });
                layers.push(arcLayer);
            }

                // Points layer - icons for source (▲) and destination (▼)
            // Moved outside of showArcs block so points can display independently
            if (showPoints && currentDataSource !== 'heatmap') {
                    const sourcePointsMap = new Map();
                    const destPointsMap = new Map();
                    
                    // Collect all unique points BY COORDINATES (not by name)
                    filteredRoutes.forEach(r => {
                        if (r.source && r.source.coordinates) {
                            const coords = r.source.coordinates;
                            const key = `${coords[0].toFixed(3)}_${coords[1].toFixed(3)}`;
                            
                            if (!sourcePointsMap.has(key)) {
                                sourcePointsMap.set(key, {
                                    position: coords,
                                    type: 'source',
                                name: r.source.name,
                                    country: r.source.country,
                                    is_urban: r.source.is_urban,
                                    routes: []
                                });
                            }
                            sourcePointsMap.get(key).routes.push(r);
                        }
                        if (r.destination && r.destination.coordinates) {
                            const coords = r.destination.coordinates;
                            const key = `${coords[0].toFixed(3)}_${coords[1].toFixed(3)}`;
                            
                            if (!destPointsMap.has(key)) {
                                destPointsMap.set(key, {
                                    position: coords,
                                    type: 'destination',
                                name: r.destination.name,
                                    country: r.destination.country,
                                    is_urban: r.destination.is_urban,
                                    routes: []
                                });
                            }
                            destPointsMap.get(key).routes.push(r);
                        }
                    });
                    
                    const sourcePoints = Array.from(sourcePointsMap.values());
                    const destPoints = Array.from(destPointsMap.values());

                    // Icon mapping for triangles
                    const ICON_MAPPING = {
                        triangle_up: {x: 0, y: 0, width: 128, height: 128, mask: true},
                        triangle_down: {x: 0, y: 0, width: 128, height: 128, mask: true}
                    };

                // Source icons layer (▲)
                    const sourceLayer = new IconLayer({
                    id: 'source-icons-layer-independent',
                        data: sourcePoints,
                        getPosition: d => d.position,
                        getIcon: d => 'triangle_up',
                        getColor: d => {
                            let isHighlighted = true;
                            
                            if (selectedPoint) {
                                if (selectedPoint.type === 'source') {
                                    const pointCoords = d.position;
                                    isHighlighted = (
                                        pointCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                        pointCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                    ) || (d.routes && d.routes.some(r => {
                                        const srcCoords = r.source.coordinates;
                                        return srcCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                               srcCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3);
                                    }));
                                } else if (selectedPoint.type === 'destination') {
                                    isHighlighted = d.routes && d.routes.some(r => {
                                        const destCoords = r.destination.coordinates;
                                        return destCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                               destCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3);
                                    });
                                }
                            }
                            else if (selectedRoute) {
                                isHighlighted = d.routes && d.routes.some(r => 
                                    r.source.name === selectedRoute.source.name && 
                                    r.destination.name === selectedRoute.destination.name
                                );
                            }
                            else if (hoveredRoute) {
                                isHighlighted = d.routes && d.routes.some(r => 
                                    r.source.name === hoveredRoute.source.name && 
                                    r.destination.name === hoveredRoute.destination.name
                                );
                            }
                            
                            let color;
                            if (colorMode === 'rural_urban') {
                                color = getLocationColor(d.is_urban);
                            } else if (colorMode === 'source_destination') {
                            color = getPointTypeColor(true);
                            } else {
                            color = getPointTypeColor(true);
                            }
                            const alpha = isHighlighted ? 200 : 5;
                            return [color[0], color[1], color[2], alpha];
                        },
                    getSize: 22,
                        sizeMinPixels: 7,
                        sizeMaxPixels: 30,
                        iconAtlas: 'data:image/svg+xml;base64,' + btoa(`
                            <svg width="128" height="128" xmlns="http://www.w3.org/2000/svg">
                                <path d="M 64 28 L 102 88 L 26 88 Z" fill="white" stroke="rgba(0,0,0,0.3)" stroke-width="3"/>
                            </svg>
                        `),
                        iconMapping: ICON_MAPPING,
                        pickable: true,
                        onHover: handleHover,
                        onClick: handleClick,
                        updateTriggers: {
                            getColor: [colorMode, hoveredRoute, selectedRoute, selectedPoint]
                        }
                    });
                    layers.push(sourceLayer);

                // Destination icons layer (▼)
                    const destLayer = new IconLayer({
                    id: 'dest-icons-layer-independent',
                        data: destPoints,
                        getPosition: d => d.position,
                        getIcon: d => 'triangle_down',
                        getColor: d => {
                            let isHighlighted = true;
                            
                            if (selectedPoint) {
                                if (selectedPoint.type === 'destination') {
                                    const pointCoords = d.position;
                                    isHighlighted = (
                                        pointCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                        pointCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                    ) || (d.routes && d.routes.some(r => {
                                        const destCoords = r.destination.coordinates;
                                        return destCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                               destCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3);
                                    }));
                                } else if (selectedPoint.type === 'source') {
                                    isHighlighted = d.routes && d.routes.some(r => {
                                        const srcCoords = r.source.coordinates;
                                        return srcCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                               srcCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3);
                                    });
                                }
                            }
                            else if (selectedRoute) {
                                isHighlighted = d.routes && d.routes.some(r => 
                                    r.source.name === selectedRoute.source.name && 
                                    r.destination.name === selectedRoute.destination.name
                                );
                            }
                            else if (hoveredRoute) {
                                isHighlighted = d.routes && d.routes.some(r => 
                                    r.source.name === hoveredRoute.source.name && 
                                    r.destination.name === hoveredRoute.destination.name
                                );
                            }
                            
                            let color;
                            if (colorMode === 'rural_urban') {
                                color = getLocationColor(d.is_urban);
                            } else if (colorMode === 'source_destination') {
                            color = getPointTypeColor(false);
                            } else {
                            color = getPointTypeColor(false);
                            }
                            const alpha = isHighlighted ? 200 : 5;
                            return [color[0], color[1], color[2], alpha];
                        },
                    getSize: 22,
                        sizeMinPixels: 7,
                        sizeMaxPixels: 30,
                        iconAtlas: 'data:image/svg+xml;base64,' + btoa(`
                            <svg width="128" height="128" xmlns="http://www.w3.org/2000/svg">
                                <path d="M 64 100 L 26 40 L 102 40 Z" fill="white" stroke="rgba(0,0,0,0.3)" stroke-width="3"/>
                            </svg>
                        `),
                        iconMapping: ICON_MAPPING,
                        pickable: true,
                        onHover: handleHover,
                        onClick: handleClick,
                        updateTriggers: {
                            getColor: [colorMode, hoveredRoute, selectedRoute, selectedPoint]
                        }
                    });
                    layers.push(destLayer);
                }

            // Via city visualization - moved outside showArcs so it can display independently
            if (showViaCity && currentDataSource !== 'heatmap') {
                    // Extract unique via cities from filtered routes
                    const viaCityMap = new Map();
                    filteredRoutes.forEach(r => {
                        if (r.via_city && r.via_city.coordinates) {
                            const key = r.via_city.name;
                            if (!viaCityMap.has(key)) {
                                viaCityMap.set(key, {
                                    name: r.via_city.name,
                                    coordinates: r.via_city.coordinates,
                                    routeCount: 0
                                });
                            }
                            viaCityMap.get(key).routeCount++;
                        }
                    });
                    const viaCityPoints = Array.from(viaCityMap.values());

                    // City color mapping
                    const cityColors = {
                    'Bamako': [255, 165, 0],
                    'Tamale': [46, 204, 113],
                    'Ouagadougou': [52, 152, 219],
                    'Bamenda': [155, 89, 182]
                    };

                    // Elevated sphere layer for via cities
                    const viaCitySphereLayer = new deck.ScatterplotLayer({
                    id: 'via-city-spheres-independent',
                        data: viaCityPoints,
                    getPosition: d => [...d.coordinates, 500],
                    getRadius: 25000,
                        getFillColor: d => {
                            const color = cityColors[d.name] || [255, 165, 0];
                        return [...color, 200];
                        },
                        stroked: true,
                        getLineColor: d => {
                            const color = cityColors[d.name] || [255, 165, 0];
                            return [...color, 255];
                        },
                        lineWidthMinPixels: 2,
                        pickable: true,
                        onHover: handleHover
                    });
                    layers.push(viaCitySphereLayer);

                    // Vertical line layer from sphere to ground
                    const viaCityLineLayer = new deck.LineLayer({
                    id: 'via-city-lines-independent',
                        data: viaCityPoints,
                    getSourcePosition: d => [...d.coordinates, 500],
                    getTargetPosition: d => [...d.coordinates, 0],
                        getColor: d => {
                            const color = cityColors[d.name] || [255, 165, 0];
                        return [...color, 200];
                        },
                    getWidth: 5,
                        widthMinPixels: 3
                    });
                    layers.push(viaCityLineLayer);
            }

            deckgl.setProps({ layers });
        }

        function handleClick(info) {
            if (info.object && info.object.source && info.object.destination) {
                // Clicked on a route (arc)
                const clickedRoute = info.object._segment ? 
                    filteredRoutes.find(r => 
                        r.source.name === info.object.source.name && 
                        r.destination.name === info.object.destination.name
                    ) : info.object;
                
                // Toggle route selection, clear point selection
                selectedPoint = null;
                if (selectedRoute === clickedRoute) {
                    selectedRoute = null;
                } else {
                    selectedRoute = clickedRoute;
                }
                updateVisualization();
                
            } else if (info.object && info.object.position && info.object.type) {
                // Clicked on a point (source or destination)
                const clickedPoint = {
                    position: info.object.position,
                    type: info.object.type
                };
                
                // Toggle point selection, clear route selection
                selectedRoute = null;
                if (selectedPoint && 
                    selectedPoint.position[0] === clickedPoint.position[0] && 
                    selectedPoint.position[1] === clickedPoint.position[1] && 
                    selectedPoint.type === clickedPoint.type) {
                    selectedPoint = null; // Deselect if clicking same point
            } else {
                    selectedPoint = clickedPoint;
                }
                updateVisualization();
                
            } else {
                // Click on empty space - clear all selections
                if (selectedRoute || selectedPoint) {
                    selectedRoute = null;
                    selectedPoint = null;
                    updateVisualization();
                }
            }
        }

        function handleHover(info) {
            const tooltip = document.getElementById('tooltip');
            
            // Update hovered route for highlighting
            if (info.object && info.object.source && info.object.destination) {
                // Get the original route (not the segment)
                hoveredRoute = info.object._segment ? 
                    filteredRoutes.find(r => 
                        r.source.name === info.object.source.name && 
                        r.destination.name === info.object.destination.name
                    ) : info.object;
                updateVisualization();
            } else if (!info.object && !selectedRoute) {
                // Only clear hover if nothing is selected
                if (hoveredRoute) {
                    hoveredRoute = null;
                    updateVisualization();
                }
            }
            
            if (info.object) {
                const obj = info.object;
                let html = '';

                if (obj.source && obj.destination) {
                    // Arc (route) tooltip - use _displayData for precise values
                    const displayData = obj._displayData || obj;
                    
                    // Build title with via_city
                    let titlePrefix = '';
                    if (colorMode === 'rural_urban') {
                        const sourceIcon = obj.source.is_urban ? '🏙️' : '🏘️';
                        const destIcon = obj.destination.is_urban ? '🏙️' : '🏘️';
                        
                        // Show three-point route with via_city
                        if (obj.via_city && obj.via_city.name) {
                            titlePrefix = `${sourceIcon} ${obj.source.name} → ${obj.via_city.name} → ${destIcon} ${obj.destination.name}`;
                        } else {
                            titlePrefix = `${sourceIcon} ${obj.source.name} → ${destIcon} ${obj.destination.name}`;
                        }
                    } else if (colorMode === 'source_destination') {
                        // Show with source/destination icons
                        if (obj.via_city && obj.via_city.name) {
                            titlePrefix = `📤 ${obj.source.name} → ${obj.via_city.name} → 📥 ${obj.destination.name}`;
                        } else {
                            titlePrefix = `📤 ${obj.source.name} → 📥 ${obj.destination.name}`;
                        }
                    } else {
                        // Show three-point route
                        if (obj.via_city && obj.via_city.name) {
                            titlePrefix = `${obj.source.name} → ${obj.via_city.name} → ${obj.destination.name}`;
                        } else {
                            titlePrefix = `${obj.source.name} → ${obj.destination.name}`;
                        }
                    }
                    
                    html = `
                        <div class="tooltip-title">${titlePrefix}</div>
                        <div class="tooltip-item">📦 Quantity: ${(displayData.quantity || 0).toLocaleString()}</div>
                        <div class="tooltip-item">🔄 Flows: ${(displayData.flows || 0).toLocaleString()}</div>
                    `;
                    
                    // Show year range if multiple years
                    if (displayData.years && displayData.years.length > 0) {
                        const yearDisplay = displayData.years.length === 1 
                            ? displayData.years[0]
                            : `${Math.min(...displayData.years)}-${Math.max(...displayData.years)}`;
                        html += `<div class="tooltip-item">📅 Year: ${yearDisplay}</div>`;
                    }
                    
                    // Show flow type based on color mode
                    if (colorMode === 'rural_urban' && obj.flow_type_label) {
                        html += `<div class="tooltip-item">🔀 ${obj.flow_type_label}</div>`;
                    } else if (colorMode === 'international') {
                        html += `<div class="tooltip-item">${obj.is_international ? '🌐 International' : '🏠 Domestic'}</div>`;
                    } else if (colorMode === 'source_destination') {
                        html += `<div class="tooltip-item">📤 Source → 📥 Destination</div>`;
                    }
                    
                    html += `<div class="tooltip-item">📍 ${obj.source.country} → ${obj.destination.country}</div>`;
                    
                    // Show main transportation mode from displayData
                    if (displayData.main_transport) {
                        html += `<div class="tooltip-item">🚗 ${displayData.main_transport}</div>`;
                    }
                    
                    // Show commodities from displayData (precise for filters)
                    if (displayData.commodities) {
                        const commodities = displayData.commodities;
                        const commList = Object.entries(commodities).slice(0, 3)
                            .map(([name, count]) => `${name} (${count})`)
                            .join(', ');
                        html += `<div class="tooltip-commodities">📦 ${commList}</div>`;
                    }
                } else if (obj.name) {
                    // Point tooltip (source, destination, or via_city)
                    if (obj.routeCount !== undefined) {
                        // Via city point
                        html = `
                            <div class="tooltip-title">🏙️ ${obj.name}</div>
                            <div class="tooltip-item">Transit City</div>
                            <div class="tooltip-item">🔄 ${obj.routeCount} routes pass through</div>
                        `;
                    } else {
                        // Source or destination point
                        const urbanStatus = obj.is_urban !== undefined ? (obj.is_urban ? '🏙️ Urban' : '🏘️ Rural') : '';
                        const pointTypeLabel = obj.type === 'source' ? '📤 Source' : '📥 Destination';
                        html = `
                            <div class="tooltip-title">${obj.name}</div>
                            <div class="tooltip-item">📍 ${obj.country}</div>
                            ${urbanStatus && colorMode === 'rural_urban' ? `<div class="tooltip-item">${urbanStatus}</div>` : ''}
                            <div class="tooltip-item">${pointTypeLabel}</div>
                        `;
                    }
                }

                tooltip.innerHTML = html;
                tooltip.style.display = 'block';
                tooltip.style.left = info.x + 'px';
                tooltip.style.top = info.y + 'px';
            } else {
                tooltip.style.display = 'none';
            }
        }

        // ========== New Interactive Filter Functions ==========

        function selectColorMode(element, mode) {
            // Update visual selection
            const items = element.parentElement.querySelectorAll('.filter-bar-item');
            items.forEach(item => item.classList.remove('active'));
            element.classList.add('active');
            
            // Apply filter
            switchColorMode(mode);
        }

        // 统计图表选择函数 (Multi-select toggle)
        function selectRuralUrbanStat(element, type) {
            // Toggle multi-select
            const index = selectedFilters.ruralUrban.indexOf(type);
            if (index > -1) {
                selectedFilters.ruralUrban.splice(index, 1);
            } else {
                selectedFilters.ruralUrban.push(type);
            }
            filterAndUpdate();
        }

        function selectTradeTypeStat(element, type) {
            // Toggle multi-select
            const index = selectedFilters.tradeTypes.indexOf(type);
            if (index > -1) {
                selectedFilters.tradeTypes.splice(index, 1);
            } else {
                selectedFilters.tradeTypes.push(type);
            }
            filterAndUpdate();
        }

        function selectYearStat(element, year) {
            // Toggle multi-select
            const index = selectedFilters.years.indexOf(year);
            if (index > -1) {
                selectedFilters.years.splice(index, 1);
            } else {
                selectedFilters.years.push(year);
            }
            filterAndUpdate();
        }

        function selectRouteFilterStat(element, filter) {
            const bars = element.parentElement.querySelectorAll('.stat-bar');
            bars.forEach(bar => bar.classList.remove('active'));
            element.classList.add('active');
            
            switchDataSource(filter);
        }

        function selectCommodity(element, commodity) {
            // Toggle multi-select (except 'all')
            if (commodity === 'all') {
                // Clear all selections and select 'all'
                selectedFilters.commodities = [];
            const cards = element.parentElement.querySelectorAll('.commodity-card');
            cards.forEach(card => card.classList.remove('active'));
            element.classList.add('active');
            } else {
                // Toggle this commodity
                const index = selectedFilters.commodities.indexOf(commodity);
                if (index > -1) {
                    // Deselect
                    selectedFilters.commodities.splice(index, 1);
                    element.classList.remove('active');
                    
                    // If no commodities selected, select 'all'
                    if (selectedFilters.commodities.length === 0) {
                        const allCard = Array.from(element.parentElement.querySelectorAll('.commodity-card'))
                            .find(card => card.querySelector('.commodity-name')?.textContent === 'All');
                        if (allCard) allCard.classList.add('active');
                    }
                } else {
                    // Select
                    selectedFilters.commodities.push(commodity);
            element.classList.add('active');
            
                    // Deselect 'all' if it was selected
                    const allCard = Array.from(element.parentElement.querySelectorAll('.commodity-card'))
                        .find(card => card.querySelector('.commodity-name')?.textContent === 'All');
                    if (allCard) allCard.classList.remove('active');
                }
            }
            
            filterAndUpdate();
        }

        function selectTransport(element, transport) {
            // Toggle multi-select (except 'all')
            if (transport === 'all') {
                // Clear all selections and select 'all'
                selectedFilters.transports = [];
            const items = element.parentElement.querySelectorAll('.filter-bar-item');
            items.forEach(item => item.classList.remove('active'));
            element.classList.add('active');
            } else {
                // Toggle this transport
                const index = selectedFilters.transports.indexOf(transport);
                if (index > -1) {
                    // Deselect
                    selectedFilters.transports.splice(index, 1);
                    element.classList.remove('active');
                    
                    // If no transports selected, select 'all'
                    if (selectedFilters.transports.length === 0) {
                        const allItem = Array.from(element.parentElement.querySelectorAll('.filter-bar-item'))
                            .find(item => item.querySelector('.filter-bar-label')?.textContent === 'All Modes');
                        if (allItem) allItem.classList.add('active');
                    }
                } else {
                    // Select
                    selectedFilters.transports.push(transport);
            element.classList.add('active');
            
                    // Deselect 'all' if it was selected
                    const allItem = Array.from(element.parentElement.querySelectorAll('.filter-bar-item'))
                        .find(item => item.querySelector('.filter-bar-label')?.textContent === 'All Modes');
                    if (allItem) allItem.classList.remove('active');
                }
            }
            
            filterAndUpdate();
        }

        function selectViaCity(element, viaCity) {
            // Toggle multi-select (except 'all')
            if (viaCity === 'all') {
                // Clear all selections and select 'all'
                selectedFilters.viaCities = [];
            const items = element.parentElement.querySelectorAll('.filter-bar-item');
            items.forEach(item => item.classList.remove('active'));
            element.classList.add('active');
            } else {
                // Toggle this via city
                const index = selectedFilters.viaCities.indexOf(viaCity);
                if (index > -1) {
                    // Deselect
                    selectedFilters.viaCities.splice(index, 1);
                    element.classList.remove('active');
                    
                    // If no via cities selected, select 'all'
                    if (selectedFilters.viaCities.length === 0) {
                        const allItem = Array.from(element.parentElement.querySelectorAll('.filter-bar-item'))
                            .find(item => item.querySelector('.filter-bar-label')?.textContent === 'All Routes');
                        if (allItem) allItem.classList.add('active');
                    }
                } else {
                    // Select
                    selectedFilters.viaCities.push(viaCity);
                    element.classList.add('active');
                    
                    // Deselect 'all' if it was selected
                    const allItem = Array.from(element.parentElement.querySelectorAll('.filter-bar-item'))
                        .find(item => item.querySelector('.filter-bar-label')?.textContent === 'All Routes');
                    if (allItem) allItem.classList.remove('active');
                }
            }
            
            filterAndUpdate();
        }

        // ========== Control Panel Toggle ==========
        
        function toggleControlPanel() {
            const panel = document.getElementById('control-panel');
            const toggle = document.getElementById('panelToggle');
            const icon = document.getElementById('toggleIcon');
            
            panel.classList.toggle('collapsed');
            toggle.classList.toggle('collapsed');
            
            if (panel.classList.contains('collapsed')) {
                icon.textContent = '▶'; // Point right when collapsed
                toggle.setAttribute('data-tooltip', 'Show filters (F)');
            } else {
                icon.textContent = '◀'; // Point left when expanded
                toggle.setAttribute('data-tooltip', 'Hide filters (F)');
            }
        }

        // ========== Event Listeners ==========

        function setupEventListeners() {
            // Arc width - real-time update
            document.getElementById('arcWidth').addEventListener('input', function() {
                const value = parseFloat(this.value).toFixed(1);
                document.getElementById('arcWidthValue').textContent = value;
                updateVisualization();
            });

            // Show arcs
            document.getElementById('showArcs').addEventListener('change', updateVisualization);

            // Show points
            document.getElementById('showPoints').addEventListener('change', updateVisualization);
            
            // Show via city
            document.getElementById('showViaCity').addEventListener('change', updateVisualization);
            
            // Keyboard shortcut: Press 'F' to toggle control panel
            document.addEventListener('keydown', function(e) {
                if (e.key === 'f' || e.key === 'F') {
                    // Only toggle if not typing in an input
                    if (!e.target.matches('input, textarea, select')) {
                        toggleControlPanel();
                    }
                }
            });
        }


        // Initialize
        init();
    </script>
</body>
</html>


