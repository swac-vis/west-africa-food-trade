<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>African Food Flows - Complete Visualization</title>
    <script src="https://unpkg.com/deck.gl@latest/dist.min.js"></script>
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
            background: #0a1929;
        }

        .header {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 20px 25px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            z-index: 10;
            max-width: 350px;
        }

        .header h1 {
            font-size: 1.5rem;
            margin-bottom: 5px;
            color: #1a202c;
            font-weight: 700;
        }

        .header .subtitle {
            font-size: 0.85rem;
            color: #718096;
            line-height: 1.4;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: white;
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            max-width: 320px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            z-index: 10;
        }

        .control-panel h3 {
            font-size: 0.9rem;
            margin-bottom: 16px;
            color: #2d3748;
            font-weight: 600;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 8px;
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #4a5568;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        select, input[type="range"] {
            width: 100%;
            padding: 8px 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 0.875rem;
            transition: border-color 0.2s;
        }

        select:focus {
            outline: none;
            border-color: #4299e1;
        }

        input[type="range"] {
            padding: 0;
            height: 6px;
            cursor: pointer;
        }

        /* 极简交互图表 */
        .filter-chart {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 6px;
        }

        .filter-bars {
            display: flex;
            flex-direction: column;
            gap: 3px;
            max-height: 200px;
            overflow-y: auto;
        }

        .filter-bar-item {
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: all 0.15s;
            padding: 3px 5px;
            border-radius: 3px;
            background: white;
            border: 1px solid transparent;
        }

        .filter-bar-item:hover {
            background: #f1f3f4;
            border-color: #dee2e6;
        }

        .filter-bar-item.active {
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }

        .filter-bar-label {
            min-width: 70px;
            font-size: 0.65rem;
            font-weight: 500;
        }

        .bar-container {
            flex: 1;
            height: 10px;
            background: #e9ecef;
            border-radius: 2px;
            overflow: hidden;
            margin: 0 5px;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            background: #6c757d;
            border-radius: 2px;
            transition: width 0.2s ease;
        }

        .filter-bar-item.active .bar-fill {
            background: white;
        }

        .bar-value {
            font-size: 0.6rem;
            font-weight: 600;
            min-width: 30px;
            text-align: right;
            color: #6c757d;
        }

        .filter-bar-item.active .bar-value {
            color: white;
        }

        /* 年份时间轴 */
        .year-timeline {
            display: flex;
            gap: 3px;
            margin-top: 6px;
        }

        .year-button {
            flex: 1;
            padding: 6px 4px;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 3px;
            font-size: 0.65rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
        }

        .year-button:hover {
            border-color: #007bff;
            background: #f8f9ff;
        }

        .year-button.active {
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }

        /* 商品网格 */
        .commodity-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 3px;
            margin-top: 6px;
            max-height: 200px;
            overflow-y: auto;
        }

        .commodity-card {
            padding: 4px 3px;
            border: 1px solid #dee2e6;
            border-radius: 3px;
            background: white;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
        }

        .commodity-card:hover {
            border-color: #007bff;
            background: #f8f9ff;
        }

        .commodity-card.active {
            background: #007bff;
            border-color: #0056b3;
            color: white;
        }

        .commodity-card.active .commodity-bar {
            background: white !important;
        }

        .commodity-name {
            font-size: 0.6rem;
            font-weight: 500;
            margin-bottom: 1px;
            line-height: 1.1;
        }

        .commodity-count {
            font-size: 0.55rem;
            opacity: 0.8;
            line-height: 1;
        }

        /* 模式切换 */
        .view-mode-toggle {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
        }

        .mode-btn {
            flex: 1;
            padding: 6px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 3px;
            font-size: 0.65rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }

        .mode-btn.active {
            background: #495057;
            color: white;
            border-color: #343a40;
        }

        /* 统计图表样式 */
        .stats-chart {
            display: flex;
            align-items: end;
            gap: 2px;
            height: 40px;
            margin: 6px 0;
            padding: 4px;
            background: #f8f9fa;
            border-radius: 3px;
        }

        .stat-bar {
            flex: 1;
            background: #6c757d;
            border-radius: 2px 2px 0 0;
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
            height: 20%; /* Default height before data loads */
        }

        .stat-bar:hover {
            background: #007bff;
        }

        .stat-bar.active {
            background: #007bff;
        }

        .stat-bar-label {
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.6rem;
            color: #6c757d;
            white-space: nowrap;
        }

        .stat-bar.active .stat-bar-label {
            color: #007bff;
            font-weight: 600;
        }

        /* 横向堆叠条形图 */
        .stacked-bar-container {
            margin: 6px 0;
        }

        .stacked-bar-chart {
            display: flex;
            width: 100%;
            height: 28px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
        }

        .stacked-bar-segment {
            height: 100%;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid rgba(255,255,255,0.3);
        }

        .stacked-bar-segment:last-child {
            border-right: none;
        }

        .stacked-bar-segment:hover {
            filter: brightness(1.1);
        }

        .stacked-bar-segment.selected {
            filter: brightness(1.2);
            box-shadow: inset 0 0 0 2px rgba(255,255,255,0.5);
        }

        .stacked-bar-label {
            font-size: 0.65rem;
            font-weight: 600;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1.2;
        }

        .stacked-bar-label-year {
            font-size: 0.7rem;
        }

        .stacked-bar-label-count {
            font-size: 0.6rem;
            opacity: 0.9;
        }

        .stacked-bar-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
            padding: 6px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .legend-item-compact {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.65rem;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            transition: all 0.15s;
        }

        .legend-item-compact:hover {
            background: white;
        }

        .legend-item-compact.selected {
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .legend-color-box {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            flex-shrink: 0;
        }

        .legend-item-compact .legend-label {
            color: #495057;
            font-weight: 500;
        }

        .legend-item-compact.selected .legend-label {
            color: #007bff;
            font-weight: 600;
        }

        .legend-item-compact .legend-value {
            color: #6c757d;
            margin-left: 2px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .stat-card {
            background: #f7fafc;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #2d3748;
            line-height: 1;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #718096;
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend {
            margin-top: 18px;
            padding-top: 18px;
            border-top: 2px solid #edf2f7;
        }

        .legend-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }

        .legend-line {
            width: 35px;
            height: 3px;
            margin-right: 10px;
            border-radius: 2px;
        }

        .legend-triangle {
            width: 0;
            height: 0;
            margin-right: 10px;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
        }

        .legend-triangle-up {
            border-bottom: 14px solid;
        }

        .legend-triangle-down {
            border-top: 14px solid;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            padding: 10px;
            background: #f7fafc;
            border-radius: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-group label {
            margin: 0;
            font-weight: 500;
            cursor: pointer;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px 60px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            z-index: 1000;
            text-align: center;
        }

        .loading-spinner {
            font-size: 3rem;
            margin-bottom: 15px;
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.1rem;
            color: #2d3748;
            font-weight: 600;
        }

        .loading-subtext {
            font-size: 0.9rem;
            color: #718096;
            margin-top: 8px;
        }

        .tooltip {
            position: absolute;
            padding: 12px 16px;
            background: rgba(26, 32, 44, 0.95);
            color: white;
            border-radius: 8px;
            pointer-events: none;
            z-index: 100;
            font-size: 0.875rem;
            max-width: 280px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            display: none;
        }

        .tooltip-title {
            font-weight: 700;
            margin-bottom: 6px;
            font-size: 0.95rem;
        }

        .tooltip-item {
            margin: 4px 0;
            font-size: 0.85rem;
        }

        .tooltip-commodities {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.2);
            font-size: 0.8rem;
        }

        .range-value {
            display: inline-block;
            background: #4299e1;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            margin-left: 8px;
            font-weight: 600;
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }

    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="loading" id="loading">
        <div class="loading-spinner">🌍</div>
        <div class="loading-text">Loading African Food Flows</div>
        <div class="loading-subtext">Preparing 80,762 trade records...</div>
    </div>

    <div class="header">
        <h1>🌾 African Food Flows</h1>
        <div class="subtitle">
            Visualizing food trade in west africa from 2013-2017. 
            Complete dataset with 80,762 recorded trades.
        </div>
    </div>

    <div class="control-panel" id="control-panel" style="display: none;">
        <h3>Interactive Filters</h3>
        
        <!-- View Mode Toggle -->
        <div class="view-mode-toggle">
            <div class="mode-btn active" onclick="toggleFilterMode('interactive')">Chart</div>
            <div class="mode-btn" onclick="toggleFilterMode('traditional')">List</div>
        </div>

        <!-- Interactive Mode (default) -->
        <div id="interactiveMode">
            <!-- Color Mode -->
            <div class="control-group">
                <label>Color Mode</label>
                <div class="filter-bars">
                    <div class="filter-bar-item active color-mode-bar" data-mode="source_destination" onclick="selectColorMode(this, 'source_destination')">
                        <span class="filter-bar-label">Source-Dest</span>
                        <div class="bar-container"><div class="bar-fill"></div></div>
                        <span class="bar-value">Default</span>
                    </div>
                    <div class="filter-bar-item color-mode-bar" data-mode="rural_urban" onclick="selectColorMode(this, 'rural_urban')">
                        <span class="filter-bar-label">Rural-Urban</span>
                        <div class="bar-container"><div class="bar-fill"></div></div>
                        <span class="bar-value"></span>
                    </div>
                    <div class="filter-bar-item color-mode-bar" data-mode="international" onclick="selectColorMode(this, 'international')">
                        <span class="filter-bar-label">Trade Type</span>
                        <div class="bar-container"><div class="bar-fill"></div></div>
                        <span class="bar-value"></span>
                    </div>
                </div>
            </div>

            <!-- Rural-Urban Flow Pattern (always visible) -->
            <div class="control-group" id="ruralUrbanFilterGroup">
                <label>Flow Pattern</label>
                <div class="stacked-bar-container">
                    <div class="stacked-bar-chart" id="ruralUrbanStackedBar">
                        <!-- Dynamically generated -->
                    </div>
                </div>
            </div>

            <!-- Trade Type (always visible) -->
            <div class="control-group" id="tradeTypeFilterGroup">
                <label>Trade Type</label>
                <div class="stacked-bar-container">
                    <div class="stacked-bar-chart" id="tradeTypeStackedBar">
                        <!-- Dynamically generated -->
                    </div>
                </div>
            </div>

            <!-- Year Distribution -->
            <div class="control-group">
                <label>Year Distribution</label>
                <div class="stacked-bar-container">
                    <div class="stacked-bar-chart" id="yearStackedBar">
                        <!-- Dynamically generated -->
                    </div>
                </div>
            </div>

            <!-- Commodities -->
            <div class="control-group">
                <label id="commodityLabel">Commodities</label>
                <div class="commodity-grid" id="commodityGrid" style="max-height: 250px;">
                    <!-- Dynamically generated from data -->
                </div>
            </div>

            <!-- Transport Modes -->
            <div class="control-group">
                <label id="transportLabel">Transport</label>
                <div class="filter-bars" id="transportBars" style="max-height: 250px;">
                    <!-- Dynamically generated from data -->
                </div>
            </div>

            <!-- Route Filter -->
            <div class="control-group">
                <label>Route Filter</label>
                <div class="stats-chart">
                    <div class="stat-bar active" onclick="selectRouteFilterStat(this, 'all')">
                        <div class="stat-bar-label">All</div>
                    </div>
                    <div class="stat-bar" onclick="selectRouteFilterStat(this, 'major')">
                        <div class="stat-bar-label">Major</div>
                    </div>
                    <div class="stat-bar" onclick="selectRouteFilterStat(this, 'top100')">
                        <div class="stat-bar-label">Top100</div>
                    </div>
                    <div class="stat-bar" onclick="selectRouteFilterStat(this, 'heatmap')">
                        <div class="stat-bar-label">Heatmap</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Traditional Mode (hidden by default) -->
        <div id="traditionalMode" style="display: none;">
        <div class="control-group">
            <label>Route Filter</label>
            <select id="routeFilter">
                <option value="all" selected>All Routes (complete data)</option>
                <option value="major">Major Routes (flows ≥ 10)</option>
                <option value="top100">Top 100 (busiest)</option>
                <option value="heatmap">Heatmap (aggregated)</option>
            </select>
        </div>

        <div class="control-group">
            <label>🎨 Color Mode</label>
            <select id="colorModeSelect">
                <option value="source_destination" selected>Source-Destination</option>
                <option value="rural_urban">Rural-Urban Pattern</option>
                <option value="international">International-Domestic</option>
            </select>
        </div>

        <div class="control-group">
            <label>Year</label>
            <select id="yearFilter">
                    <option value="all" selected>All Years</option>
                <option value="2013">2013</option>
                <option value="2014">2014</option>
                <option value="2015">2015</option>
                <option value="2016">2016</option>
                <option value="2017">2017</option>
            </select>
        </div>

            <div class="control-group">
                <label>Commodity</label>
                <select id="commodityFilter">
                    <!-- Dynamically generated from data -->
            </select>
        </div>

        <div class="control-group">
                <label>Transportation Mode</label>
                <select id="transportFilter">
                    <!-- Dynamically generated from data -->
            </select>
        </div>

        <div class="control-group">
                <label>🏘️ Rural-Urban Pattern</label>
                <select id="ruralUrbanFilter">
                    <option value="all" selected>All Flow Types</option>
                    <option value="rural_to_urban">🏘️→🏙️ Rural → Urban</option>
                    <option value="urban_to_rural">🏙️→🏘️ Urban → Rural</option>
                    <option value="rural_to_rural">🏘️→🏘️ Rural → Rural</option>
                    <option value="urban_to_urban">🏙️→🏙️ Urban → Urban</option>
            </select>
        </div>

        <div class="control-group">
                <label>Trade Type</label>
                <select id="tradeTypeFilter">
                    <option value="all" selected>All Trades</option>
                    <option value="international">🌐 International</option>
                    <option value="domestic">🏠 Domestic</option>
            </select>
            </div>
        </div>

        <div class="control-group">
            <label>
                Arc Thickness
                <span class="range-value" id="arcWidthValue">0.3</span>
            </label>
            <input type="range" id="arcWidth" min="0.1" max="5" value="0.3" step="0.1">
        </div>

        <div class="checkbox-group">
            <input type="checkbox" id="showPoints" checked>
            <label for="showPoints">Show location points</label>
        </div>

        <div class="checkbox-group">
            <input type="checkbox" id="showViaCity">
            <label for="showViaCity">Show transit cities (via routes)</label>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="visibleRoutes">-</div>
                <div class="stat-label" id="routesLabel">Routes</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalFlows">-</div>
                <div class="stat-label">Quantity</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="intlFlows">-</div>
                <div class="stat-label">International</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avgDistance">-</div>
                <div class="stat-label" id="distanceLabel">Avg Distance</div>
            </div>
        </div>

        <div class="legend" id="legendRuralUrban" style="display: none;">
            <div class="legend-title">Point Encoding</div>
            <div class="legend-item">
                <div class="legend-triangle legend-triangle-up" style="border-bottom-color: #FBE819;"></div>
                <span>Urban Source</span>
            </div>
            <div class="legend-item">
                <div class="legend-triangle legend-triangle-down" style="border-top-color: #FBE819;"></div>
                <span>Urban Destination</span>
            </div>
            <div class="legend-item">
                <div class="legend-triangle legend-triangle-up" style="border-bottom-color: #2A50EA;"></div>
                <span>Rural Source</span>
            </div>
            <div class="legend-item">
                <div class="legend-triangle legend-triangle-down" style="border-top-color: #2A50EA;"></div>
                <span>Rural Destination</span>
            </div>
        </div>

        <div class="legend" id="legendInternational" style="display: none;">
            <div class="legend-title">Flow Types (Arc Color)</div>
            <div class="legend-item">
                <div class="legend-line" style="background: #e53e3e;"></div>
                <span>🌐 International (6.9%)</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #3182ce;"></div>
                <span>🏠 Domestic (93.1%)</span>
            </div>
            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #edf2f7;">
                <div class="legend-title" style="margin-bottom: 8px;">Point Direction</div>
                <div class="legend-item">
                    <div class="legend-triangle legend-triangle-up" style="border-bottom-color: #888;"></div>
                    <span style="font-size: 0.85rem;">Source</span>
                </div>
                <div class="legend-item">
                    <div class="legend-triangle legend-triangle-down" style="border-top-color: #888;"></div>
                    <span style="font-size: 0.85rem;">Destination</span>
                </div>
            </div>
        </div>

        <div class="legend" id="legendSourceDest">
            <div class="legend-title">Point Type</div>
            <div class="legend-item">
                <div class="legend-triangle legend-triangle-up" style="border-bottom-color: #10b981;"></div>
                <span>Source (origin points)</span>
            </div>
            <div class="legend-item">
                <div class="legend-triangle legend-triangle-down" style="border-top-color: #ef4444;"></div>
                <span>Destination (arrival points)</span>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>


    <script>
        const {DeckGL, ArcLayer, ScatterplotLayer, HeatmapLayer, IconLayer, PathLayer} = deck;

        let allDataByYear = null; // New hierarchical data: year → route_id → route data
        let allRoutesFlat = []; // Flattened array of all routes for compatibility
        let currentDataSource = 'all';
        let filteredRoutes = [];
        let deckgl = null;
        let colorMode = 'source_destination'; // Color mode: 'source_destination', 'rural_urban', or 'international'
        
        // Global statistics for legend (all available options without any filters)
        let globalStats = {
            years: new Map(),
            ruralUrban: new Map(),
            tradeTypes: new Map()
        };
        let hoveredRoute = null; // Currently hovered route
        let selectedRoute = null; // Currently selected (clicked) route
        let selectedPoint = null; // Currently selected point {position: [lon, lat], type: 'source'|'destination'}
        

        // New hierarchical data file - organized by year
        const DATA_FILE = 'food_flows_by_year.json';

        // Global commodity mapping (lowercase key -> Exact data name from JSON)
        const COMMODITY_MAP = {
            'maize': 'Maize', 
            'rice': 'Rice', 
            'onion': 'Onion', 
            'sheep': 'Sheep',
            'yam': 'Yam', 
            'potato': 'Potato', 
            'groundnut': 'Groundnut', 
            'tomato': 'Tomato',
            'chilli_pepper': 'Chilli pepper', 
            'plantain': 'Plantain', 
            'cattle': 'Cattle',
            'fish': 'Fish', 
            'bean': 'Bean', 
            'millet': 'Millet',
            'chicken': 'Chicken',
            'mango': 'Mango',
            'cabbage': 'Cabbage',
            'banana': 'Banana',
            'goat': 'Goat',
            'soybean': 'Soybean',
            'cocoyam': 'Cocoyam',
            'eggplant': 'Eggplant',
            'gari': 'Gari',
            'watermelon': 'Watermelon',
            'okra': 'Okra',
            'cassava': 'Cassava',
            'orange': 'Orange',
            'sweet_potato': 'Sweet potato',  // 注意：小写p
            'wheat_flour': 'Wheat flour',
            'wheat': 'Wheat',
            'sorghum': 'Sorghum',
            'cucumber': 'Cucumber',
            'avocado': 'Avocado',
            'pig': 'Pig',
            'papaya': 'Papaya',
            'zucchini': 'Zucchini',
            'pineapple': 'Pineapple',
            'spring_onion': 'Spring onion',
            'guinea_fowl': 'Guinew fowl',  // 注意：数据中是Guinew，不是Guinea
            'leeks': 'Leeks',
            'sweet_pepper': 'Sweet pepper',
            'ginger': 'Ginger',
            'carrot': 'Carrot',
            'cowpea': 'Cowpea',
            'green_bean': 'Green bean',
            'bambara_beans': 'Bambara beans'
        };

        // Color configurations for stacked bar charts - use blue tones
        const STACKED_BAR_COLORS = {
            '2013': '#4A90E2',
            '2014': '#5B9FED', 
            '2015': '#6CAEF8',
            '2016': '#7DBDFF',
            '2017': '#8ECCFF',
            'rural_to_urban': '#4A90E2',
            'urban_to_rural': '#5B9FED',
            'rural_to_rural': '#6CAEF8',
            'urban_to_urban': '#7DBDFF',
            'international': '#4A90E2',
            'domestic': '#6CAEF8'
        };

        const FLOW_PATTERN_LABELS = {
            'rural_to_urban': 'R→U',
            'urban_to_rural': 'U→R',
            'rural_to_rural': 'R→R',
            'urban_to_urban': 'U→U'
        };

        const TRADE_TYPE_LABELS = {
            'international': 'International',
            'domestic': 'Domestic'
        };

        // Reverse mapping (Data name -> Display name)
        const COMMODITY_DISPLAY_MAP = {};
        Object.entries(COMMODITY_MAP).forEach(([key, value]) => {
            COMMODITY_DISPLAY_MAP[value] = value.charAt(0).toUpperCase() + value.slice(1);
        });

        /**
         * Generate dynamic filter options from loaded data
         */
        /**
         * Initialize all stat bars with actual data on page load
         */
        function initializeStatBars() {
            if (!allRoutesFlat || allRoutesFlat.length === 0) return;
            
            // Calculate all statistics from allRoutesFlat
            const stats = {
                years: new Map(),
                ruralUrban: new Map(),
                tradeTypes: new Map(),
                routeFilters: {
                    all: allRoutesFlat.length,
                    major: allRoutesFlat.filter(d => (d.flows || 0) >= 10).length,
                    top100: 100,
                    heatmap: allRoutesFlat.length  // Same as all for visual purposes
                }
            };
            
            allRoutesFlat.forEach(route => {
                // Year statistics - use quantity instead of flows
                if (route.by_year) {
                    Object.entries(route.by_year).forEach(([year, data]) => {
                        const count = stats.years.get(year) || 0;
                        stats.years.set(year, count + (data.quantity || 0));
                    });
                }
                
                // Rural-Urban statistics - use quantity instead of flows
                const flowType = route.flow_type;
                if (flowType) {
                    const count = stats.ruralUrban.get(flowType) || 0;
                    stats.ruralUrban.set(flowType, count + (route.quantity || 0));
                }
                
                // Trade type statistics - use quantity instead of flows
                const trade = route.is_international ? 'international' : 'domestic';
                const tradeCount = stats.tradeTypes.get(trade) || 0;
                stats.tradeTypes.set(trade, tradeCount + (route.quantity || 0));
            });
            
            // Save global stats for legend display
            globalStats.years = new Map(stats.years);
            globalStats.ruralUrban = new Map(stats.ruralUrban);
            globalStats.tradeTypes = new Map(stats.tradeTypes);
            
            // Update Year stat bars
            updateYearFilterOptions(stats.years);
            
            // Update Rural-Urban stat bars
            updateRuralUrbanFilterOptions(stats.ruralUrban);
            
            // Update Trade Type stat bars
            updateTradeTypeFilterOptions(stats.tradeTypes);
            
            // Update Route Filter stat bars
            updateRouteFilterBars(stats.routeFilters);
            
            // Update Color Mode bars
            updateColorModeBars(stats.ruralUrban, stats.tradeTypes);
        }

        function generateFilterOptionsFromData() {
            if (!allRoutesFlat || allRoutesFlat.length === 0) return;
            
            // Calculate commodity counts - use quantity for statistics
            const commodityCounts = new Map();
            allRoutesFlat.forEach(route => {
                if (route.by_commodity) {
                    Object.entries(route.by_commodity).forEach(([commodity, data]) => {
                        const count = commodityCounts.get(commodity) || 0;
                        commodityCounts.set(commodity, count + (data.quantity || 0));
                    });
                }
            });
            
            // Calculate transport counts - use quantity for statistics
            const transportCounts = new Map();
            allRoutesFlat.forEach(route => {
                if (route.by_transport) {
                    Object.entries(route.by_transport).forEach(([transport, data]) => {
                        const count = transportCounts.get(transport) || 0;
                        transportCounts.set(transport, count + (data.quantity || 0));
                    });
                }
            });
            
            // Update label with count
            document.getElementById('commodityLabel').textContent = `Commodities (${commodityCounts.size} types)`;
            document.getElementById('transportLabel').textContent = `Transport (${transportCounts.size} modes)`;
            
            // Generate commodity cards
            generateCommodityCards(commodityCounts);
            
            // Generate transport bars
            generateTransportBars(transportCounts);
            
            // Also update traditional mode selects
            generateTraditionalModeOptions(commodityCounts, transportCounts);
        }

        function generateCommodityCards(commodityCounts) {
            const grid = document.getElementById('commodityGrid');
            grid.innerHTML = ''; // Clear existing
            
            // Calculate total flows for "All"
            const totalFlows = Array.from(commodityCounts.values()).reduce((a, b) => a + b, 0);
            
            // Find max count for color scaling
            const maxCount = commodityCounts.size > 0 ? Math.max(...commodityCounts.values()) : 0;
            
            // Add "All" option first
            const allCard = document.createElement('div');
            allCard.className = 'commodity-card active';
            allCard.onclick = function() { selectCommodity(this, 'all'); };
            allCard.innerHTML = `
                <div class="commodity-name">All</div>
                <div class="commodity-count">${formatQuantity(totalFlows)}</div>
            `;
            grid.appendChild(allCard);
            
            // Sort commodities by count (descending)
            const sortedCommodities = Array.from(commodityCounts.entries())
                .sort((a, b) => b[1] - a[1]);
            
            // Generate card for each commodity
            sortedCommodities.forEach(([commodity, count]) => {
                // Find the key for this commodity
                let commodityKey = null;
                for (const [key, value] of Object.entries(COMMODITY_MAP)) {
                    if (value === commodity) {
                        commodityKey = key;
                        break;
                    }
                }
                
                // If no key found, create one from commodity name
                if (!commodityKey) {
                    commodityKey = commodity.toLowerCase().replace(/[^a-z0-9]+/g, '_');
                    COMMODITY_MAP[commodityKey] = commodity;
                }
                
                // Calculate intensity for bar chart (0-100)
                const intensity = maxCount > 0 ? Math.round((count / maxCount) * 100) : 0;
                
                const card = document.createElement('div');
                card.className = 'commodity-card';
                card.onclick = function() { selectCommodity(this, commodityKey); };
                card.innerHTML = `
                    <div class="commodity-name">${commodity}</div>
                    <div class="commodity-count">${formatQuantity(count)}</div>
                    <div class="commodity-bar" style="width: ${intensity}%; height: 2px; background: #6c757d; margin-top: 3px; border-radius: 1px;"></div>
                `;
                grid.appendChild(card);
            });
        }

        function generateTransportBars(transportCounts) {
            const container = document.getElementById('transportBars');
            container.innerHTML = ''; // Clear existing
            
            // Calculate total for percentages
            const total = Array.from(transportCounts.values()).reduce((a, b) => a + b, 0);
            
            // Add "All" option first
            const allBar = document.createElement('div');
            allBar.className = 'filter-bar-item active';
            allBar.onclick = function() { selectTransport(this, 'all'); };
            allBar.innerHTML = `
                <span class="filter-bar-label">All Modes</span>
                <div class="bar-container"><div class="bar-fill" style="width: 100%"></div></div>
                <span class="bar-value">100%</span>
            `;
            container.appendChild(allBar);
            
            // Sort transports by count (descending)
            const sortedTransports = Array.from(transportCounts.entries())
                .sort((a, b) => b[1] - a[1]);
            
            // Generate bar for each transport mode
            sortedTransports.forEach(([transport, count]) => {
                const percentage = Math.round((count / total) * 100);
                const bar = document.createElement('div');
                bar.className = 'filter-bar-item';
                bar.onclick = function() { selectTransport(this, transport); };
                bar.innerHTML = `
                    <span class="filter-bar-label">${transport}</span>
                    <div class="bar-container"><div class="bar-fill" style="width: ${percentage}%"></div></div>
                    <span class="bar-value">${percentage}%</span>
                `;
                container.appendChild(bar);
            });
        }

        function generateTraditionalModeOptions(commodityCounts, transportCounts) {
            // Update commodity select
            const commoditySelect = document.getElementById('commodityFilter');
            if (commoditySelect) {
                // Keep only the "All" option
                commoditySelect.innerHTML = '<option value="all" selected>All Commodities</option>';
                
                // Sort and add commodities
                const sortedCommodities = Array.from(commodityCounts.entries())
                    .sort((a, b) => b[1] - a[1]);
                
                sortedCommodities.forEach(([commodity, count]) => {
                    // Find the key
                    let commodityKey = null;
                    for (const [key, value] of Object.entries(COMMODITY_MAP)) {
                        if (value === commodity) {
                            commodityKey = key;
                            break;
                        }
                    }
                    if (!commodityKey) {
                        commodityKey = commodity.toLowerCase().replace(/[^a-z0-9]+/g, '_');
                    }
                    
                    const option = document.createElement('option');
                    option.value = commodityKey;
                    option.textContent = commodity;
                    commoditySelect.appendChild(option);
                });
            }
            
            // Update transport select
            const transportSelect = document.getElementById('transportFilter');
            if (transportSelect) {
                transportSelect.innerHTML = '<option value="all" selected>All Modes</option>';
                
                const sortedTransports = Array.from(transportCounts.entries())
                    .sort((a, b) => b[1] - a[1]);
                
                sortedTransports.forEach(([transport, count]) => {
                    const option = document.createElement('option');
                    option.value = transport;
                    option.textContent = transport;
                    transportSelect.appendChild(option);
                });
            }
        }

        async function init() {
            try {
                // Load all data once (21MB)
                await loadAllData();
                
                // Filter initial data (all routes)
                filteredRoutes = getFilteredDataBySource('all');

                document.getElementById('loading').style.display = 'none';
                document.getElementById('control-panel').style.display = 'block';

                initDeckGL();
                updateStats();  // Update statistics on initial load
                updateVisualization();
                
                // Generate dynamic filter options from data
                generateFilterOptionsFromData();
                
                // Initialize all stat bar heights based on actual data
                initializeStatBars();
                
                setupEventListeners();

            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').innerHTML = 
                    '<div class="loading-text">❌ Error loading data</div><div class="loading-subtext">' + error.message + '</div>';
            }
        }

        // Load hierarchical data and convert to flat array for compatibility
        async function loadAllData() {
            if (allDataByYear) return allRoutesFlat; // Already loaded
            
            const response = await fetch(DATA_FILE);
            allDataByYear = await response.json();
            
            // Convert hierarchical structure to flat array
            allRoutesFlat = [];
            Object.entries(allDataByYear).forEach(([year, routes]) => {
                Object.entries(routes).forEach(([routeId, routeData]) => {
                    // Convert new structure to old structure for compatibility
                    const route = {
                        source: routeData.source,
                        destination: routeData.destination,
                        via_city: routeData.via_city,
                        flows: routeData.flow,
                        quantity: routeData.quantity,
                        is_international: routeData.is_international,
                        flow_type: routeData.flow_type,
                        // path: routeData.path,  // Will be added later with OSRM
                        
                        // Convert commodity structure
                        commodities: {},
                        by_commodity: {},
                        
                        // Store all years this route appears in
                        years: [parseInt(year)],
                        
                        // Transport modes from commodity data
                        transport_modes: {},
                        by_transport: {},
                        
                        // Store by_year for filtering
                        by_year: {}
                    };
                    
                    // Extract commodities and their transports
                    Object.entries(routeData.commodity || {}).forEach(([commName, commData]) => {
                        route.commodities[commName] = commData.quantity || 0;
                        
                        // Calculate total flows for this commodity (sum of all transport flows)
                        let commodityFlows = 0;
                        Object.entries(commData.transport || {}).forEach(([transName, transData]) => {
                            commodityFlows += transData.flow || 0;
                        });
                        
                        route.by_commodity[commName] = {
                            flows: commodityFlows,  // Real flow count
                            quantity: commData.quantity || 0,  // Quantity
                            transport_modes: commData.transport || {},
                            category: commData.category
                        };
                        
                        // Aggregate transport modes
                        Object.entries(commData.transport || {}).forEach(([transName, transData]) => {
                            if (!route.transport_modes[transName]) {
                                route.transport_modes[transName] = 0;
                            }
                            route.transport_modes[transName] += transData.flow || 0;
                            
                            if (!route.by_transport[transName]) {
                                route.by_transport[transName] = {
                                    flows: 0,
                                    quantity: 0,
                                    commodities: {},
                                    years: []
                                };
                            }
                            route.by_transport[transName].flows += transData.flow || 0;
                            route.by_transport[transName].quantity += transData.quantity || 0;
                            route.by_transport[transName].commodities[commName] = transData.quantity || 0;  // Use quantity not flow
                            if (!route.by_transport[transName].years.includes(parseInt(year))) {
                                route.by_transport[transName].years.push(parseInt(year));
                            }
                        });
                    });
                    
                    // Get main transport mode
                    if (Object.keys(route.transport_modes).length > 0) {
                        route.main_transport = Object.entries(route.transport_modes)
                            .reduce((a, b) => a[1] > b[1] ? a : b)[0];
                    }
                    
                    // Store year-specific data
                    route.by_year[year] = {
                        flows: routeData.flow,
                        quantity: routeData.quantity,
                        commodities: {},
                        commodities_flows: {},  // NEW: separate flows for commodities
                        transport_modes: {}
                    };
                    
                    Object.entries(routeData.commodity || {}).forEach(([commName, commData]) => {
                        // Store quantity
                        route.by_year[year].commodities[commName] = commData.quantity || 0;
                        
                        // Calculate and store flows for this commodity
                        let commFlows = 0;
                        Object.entries(commData.transport || {}).forEach(([transName, transData]) => {
                            commFlows += transData.flow || 0;
                            
                            if (!route.by_year[year].transport_modes[transName]) {
                                route.by_year[year].transport_modes[transName] = 0;
                            }
                            route.by_year[year].transport_modes[transName] += transData.flow || 0;
                        });
                        
                        route.by_year[year].commodities_flows[commName] = commFlows;
                    });
                    
                    // Check if this route already exists (same source/dest/via_city but different year)
                    const existing = allRoutesFlat.find(r => 
                        r.source.name === route.source.name &&
                        r.destination.name === route.destination.name &&
                        (r.via_city?.name || null) === (route.via_city?.name || null)
                    );
                    
                    if (existing) {
                        // Merge with existing route
                        existing.flows += route.flows;
                        existing.quantity += route.quantity;
                        existing.years.push(parseInt(year));
                        existing.years = [...new Set(existing.years)].sort();
                        
                        // Merge commodities
                        Object.entries(route.commodities).forEach(([comm, qty]) => {
                            existing.commodities[comm] = (existing.commodities[comm] || 0) + qty;
                        });
                        
                        // Merge transport modes
                        Object.entries(route.transport_modes).forEach(([trans, count]) => {
                            existing.transport_modes[trans] = (existing.transport_modes[trans] || 0) + count;
                        });
                        
                        // Merge by_year
                        existing.by_year[year] = route.by_year[year];
                        
                        // Merge by_commodity (keep flows and quantity separate)
                        Object.entries(route.by_commodity).forEach(([comm, data]) => {
                            if (!existing.by_commodity[comm]) {
                                existing.by_commodity[comm] = {
                                    flows: data.flows || 0,
                                    quantity: data.quantity || 0,
                                    transport_modes: data.transport_modes || {},
                                    category: data.category
                                };
                            } else {
                                existing.by_commodity[comm].flows += (data.flows || 0);
                                existing.by_commodity[comm].quantity += (data.quantity || 0);
                            }
                        });
                        
                        // Merge by_transport
                        Object.entries(route.by_transport).forEach(([trans, data]) => {
                            if (!existing.by_transport[trans]) {
                                existing.by_transport[trans] = data;
                            } else {
                                existing.by_transport[trans].flows += data.flows;
                                existing.by_transport[trans].quantity += data.quantity;
                                existing.by_transport[trans].years = [...new Set([...existing.by_transport[trans].years, ...data.years])].sort();
                            }
                        });
                    } else {
                        allRoutesFlat.push(route);
                    }
                });
            });
            
            console.log(`Loaded ${allRoutesFlat.length} unique routes from ${Object.keys(allDataByYear).length} years`);
            return allRoutesFlat;
        }

        /**
         * Generate heatmap data from routes by aggregating to grid
         * Grid size: 0.5 degrees (approximately 55km at equator)
         */
        function generateHeatmapFromRoutes(routes) {
            const gridSize = 0.5;
            const gridMap = new Map();
            
            // Helper function to round coordinate to grid
            const roundToGrid = (coord) => Math.round(coord / gridSize) * gridSize;
            
            // Aggregate all source and destination points
            routes.forEach(route => {
                // Add source point
                if (route.source && route.source.coordinates) {
                    const [lon, lat] = route.source.coordinates;
                    const gridKey = `${roundToGrid(lon)},${roundToGrid(lat)}`;
                    
                    if (!gridMap.has(gridKey)) {
                        gridMap.set(gridKey, {
                            coordinates: [roundToGrid(lon), roundToGrid(lat)],
                            weight: 0,
                            quantity: 0,
                            type: 'source'
                        });
                    }
                    const grid = gridMap.get(gridKey);
                    grid.weight += route.flows || 1;
                    grid.quantity += route.quantity || 0;
                }
                
                // Add destination point
                if (route.destination && route.destination.coordinates) {
                    const [lon, lat] = route.destination.coordinates;
                    const gridKey = `${roundToGrid(lon)},${roundToGrid(lat)}`;
                    
                    if (!gridMap.has(gridKey)) {
                        gridMap.set(gridKey, {
                            coordinates: [roundToGrid(lon), roundToGrid(lat)],
                            weight: 0,
                            quantity: 0,
                            type: 'destination'
                        });
                    }
                    const grid = gridMap.get(gridKey);
                    grid.weight += route.flows || 1;
                    grid.quantity += route.quantity || 0;
                }
            });
            
            return Array.from(gridMap.values());
        }

        // Filter data based on source type (client-side)
        function getFilteredDataBySource(source) {
            if (!allRoutesFlat || allRoutesFlat.length === 0) return [];
            
            if (source === 'heatmap') {
                // Generate heatmap from all data dynamically
                return generateHeatmapFromRoutes(allRoutesFlat);
            } else if (source === 'all') {
                return allRoutesFlat;
            } else if (source === 'major') {
                return allRoutesFlat.filter(d => (d.flows || 0) >= 10);
            } else if (source === 'top100') {
                const sorted = [...allRoutesFlat].sort((a, b) => (b.flows || 0) - (a.flows || 0));
                return sorted.slice(0, 100);
            }
            
            return allRoutesFlat;
        }

        function initDeckGL() {
            deckgl = new DeckGL({
                container: 'map',
                mapStyle: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
                initialViewState: {
                    longitude: 3,
                    latitude: 9,
                    zoom: 4.8,
                    pitch: 35,
                    bearing: 0
                },
                controller: true,
                layers: []
            });
        }

        async function switchDataSource(source) {
            // Show loading
            const loadingEl = document.getElementById('loading');
            loadingEl.style.display = 'block';
            loadingEl.querySelector('.loading-text').textContent = 'Filtering data...';
            loadingEl.querySelector('.loading-subtext').textContent = `Preparing ${source} routes`;

            try {
                // Load all data if not yet loaded
                if (!allRoutesFlat || allRoutesFlat.length === 0) {
                    loadingEl.querySelector('.loading-text').textContent = 'Loading data...';
                    loadingEl.querySelector('.loading-subtext').textContent = 'Loading hierarchical data...';
                    await loadAllData();
                }

                if (source === 'heatmap') {
                    loadingEl.querySelector('.loading-text').textContent = 'Generating heatmap...';
                    loadingEl.querySelector('.loading-subtext').textContent = 'Aggregating to grid';
                }

                currentDataSource = source;
                filterAndUpdate();

                loadingEl.style.display = 'none';

            } catch (error) {
                console.error('Error switching data:', error);
                loadingEl.querySelector('.loading-text').textContent = '❌ Error loading data';
            }
        }

        async function switchToCommodity(commodity) {
            // Don't switch data source, just trigger filtering
            // This allows filtering commodities within current data source (including rural-urban data)
            filterAndUpdate();
        }

        function switchColorMode(mode) {
            colorMode = mode;
            
            // Always show Rural-Urban and Trade Type filters (regardless of color mode)
                document.getElementById('ruralUrbanFilterGroup').style.display = 'block';
            document.getElementById('tradeTypeFilterGroup').style.display = 'block';
            
            // Toggle legends based on color mode
            if (mode === 'rural_urban') {
                document.getElementById('legendRuralUrban').style.display = 'block';
                document.getElementById('legendInternational').style.display = 'none';
                document.getElementById('legendSourceDest').style.display = 'none';
            } else if (mode === 'source_destination') {
                document.getElementById('legendRuralUrban').style.display = 'none';
                document.getElementById('legendInternational').style.display = 'none';
                document.getElementById('legendSourceDest').style.display = 'block';
            } else if (mode === 'international') {
                document.getElementById('legendRuralUrban').style.display = 'none';
                document.getElementById('legendInternational').style.display = 'block';
                document.getElementById('legendSourceDest').style.display = 'none';
            }
            
            // Refresh visualization with new colors
            filterAndUpdate();
        }

        /**
         * Get precise display data for a route based on current filters
         * Uses by_year, by_transport, by_commodity for accurate filtering
         */
        function getRouteDisplayData(route, filters) {
            // Start with full route data
            let displayData = {
                flows: route.flows,
                quantity: route.quantity,
                commodities: route.commodities,
                years: route.years,
                transport_modes: route.transport_modes,
                main_transport: route.main_transport
            };

            // Apply year filter using by_year breakdown
            if (filters.year && filters.year !== 'all' && route.by_year) {
                const yearData = route.by_year[filters.year];
                if (!yearData) return null; // Route has no data for this year
                
                displayData.flows = yearData.flows;
                displayData.quantity = yearData.quantity || 0;
                displayData.commodities = yearData.commodities;
                displayData.transport_modes = yearData.transport_modes;
                
                // Update main transport for this year
                const modes = Object.entries(yearData.transport_modes);
                if (modes.length > 0) {
                    displayData.main_transport = modes.reduce((a, b) => a[1] > b[1] ? a : b)[0];
                }
            }

            // Apply transport filter using by_transport breakdown
            if (filters.transport && filters.transport !== 'all' && route.by_transport) {
                const transportData = route.by_transport[filters.transport];
                if (!transportData) return null; // Route doesn't use this transport
                
                // If year filter was already applied, do intersection
                if (filters.year && filters.year !== 'all') {
                    const yearData = route.by_year[filters.year];
                    if (yearData && yearData.transport_modes[filters.transport]) {
                        // yearData.transport_modes stores flows
                        displayData.flows = yearData.transport_modes[filters.transport];
                        // For quantity, use transportData's quantity (approximate)
                        displayData.quantity = transportData.quantity || 0;
                        displayData.commodities = transportData.commodities; // Approximate
                    } else {
                        return null; // This transport not used in this year
                    }
                } else {
                    displayData.flows = transportData.flows;
                    displayData.quantity = transportData.quantity || 0;
                    displayData.commodities = transportData.commodities;
                    displayData.years = transportData.years;
                }
                displayData.main_transport = filters.transport;
            }

            // Apply commodity filter using by_commodity breakdown
            if (filters.commodity && filters.commodity !== 'all' && route.by_commodity) {
                const targetCommodity = COMMODITY_MAP[filters.commodity];
                const commodityData = route.by_commodity[targetCommodity];
                
                if (!commodityData) return null; // Route doesn't transport this commodity
                
                // If year filter was already applied, do intersection
                if (filters.year && filters.year !== 'all' && route.by_year && route.by_year[filters.year]) {
                    const yearData = route.by_year[filters.year];
                    if (yearData.commodities && yearData.commodities[targetCommodity]) {
                        // yearData.commodities stores quantity
                        const commodityQuantity = yearData.commodities[targetCommodity];
                        displayData.quantity = commodityQuantity;
                        displayData.commodities = { [targetCommodity]: commodityQuantity };
                        displayData.transport_modes = yearData.transport_modes; // Approximate
                        
                        // Get flows for this commodity in this year
                        displayData.flows = yearData.commodities_flows ? (yearData.commodities_flows[targetCommodity] || 0) : 0;
                    } else {
                        return null; // This commodity not transported in this year
                    }
                } else {
                    // For commodity filter alone, we show only this commodity
                displayData.commodities = { [targetCommodity]: commodityData.quantity };
                displayData.flows = commodityData.flows;  // Real flow count
                displayData.quantity = commodityData.quantity;  // Quantity
                displayData.transport_modes = commodityData.transport_modes;
                displayData.years = commodityData.years;
                }
            }

            return displayData;
        }

        /**
         * Update filter options based on current selections (filter constraints)
         * This ensures filters work together - selecting one filter constrains others
         */
        function updateFilterOptions(currentFilters) {
            // Safety check - ensure DOM elements exist
            if (!document.querySelector('.commodity-card') || !document.querySelector('.filter-bar-item')) {
                console.log('DOM not ready for filter constraints, skipping...');
                return;
            }
            
            const { year, commodity, transport, ruralUrban, tradeType } = currentFilters;
            
            // Start with routes based on currentDataSource (Route Filter)
            // For heatmap, use all routes; for others, use the filtered subset
            let baseRoutes = allRoutesFlat;
            if (currentDataSource === 'major') {
                baseRoutes = allRoutesFlat.filter(d => (d.flows || 0) >= 10);
            } else if (currentDataSource === 'top100') {
                const sorted = [...allRoutesFlat].sort((a, b) => (b.flows || 0) - (a.flows || 0));
                baseRoutes = sorted.slice(0, 100);
            }
            
            // Get all routes that match current filters (for calculating available options)
            let filteredRoutes = baseRoutes.filter(route => {
                // Apply rural-urban filter (works in all color modes)
                if (ruralUrban !== 'all' && route.flow_type !== ruralUrban) {
                    return false;
                }
                
                // Apply international-domestic filter (works in all color modes)
                if (tradeType !== 'all') {
                    if (tradeType === 'international' && !route.is_international) return false;
                    if (tradeType === 'domestic' && route.is_international) return false;
                }
                
                // Apply commodity filter
                if (commodity !== 'all' && route.by_commodity) {
                    const targetCommodity = COMMODITY_MAP[commodity];
                    if (!targetCommodity || !route.by_commodity[targetCommodity]) return false;
                }
                
                // Apply transport filter
                if (transport !== 'all' && route.by_transport) {
                    if (!route.by_transport[transport]) return false;
                }
                
                // Apply year filter
                if (year !== 'all' && route.by_year) {
                    if (!route.by_year[year]) return false;
                }
                
                return true;
            });
            
            // Calculate available options for each filter
            const availableOptions = calculateAvailableOptions(filteredRoutes, currentFilters);
            
            // Update interactive filter UI
            updateInteractiveFilterOptions(availableOptions, currentFilters);
        }

        /**
         * Calculate available options based on filtered routes
         * Uses "replacement" logic: shows what data is available if you REPLACE current filter
         */
        function calculateAvailableOptions(routes, currentFilters) {
            const { year, commodity, transport, ruralUrban, tradeType } = currentFilters;
            
            const options = {
                years: new Map(),  // Changed from Set to Map to store counts
                commodities: new Map(),
                transports: new Map(),
                ruralUrban: new Map(),
                tradeTypes: new Map()
            };
            
            // For each filter type, calculate what's available if we REPLACE that filter
            // This gives accurate counts for "what if I select this option instead"
            
            // Calculate available years (considering ALL current filters including year)
            routes.forEach(route => {
                // Skip if doesn't match any filters INCLUDING year
                const targetCommodity = commodity !== 'all' && route.by_commodity ? COMMODITY_MAP[commodity] : null;
                if (commodity !== 'all' && route.by_commodity) {
                    if (!targetCommodity || !route.by_commodity[targetCommodity]) return;
                }
                if (transport !== 'all' && route.by_transport && !route.by_transport[transport]) return;
                if (ruralUrban !== 'all' && route.flow_type !== ruralUrban) return;
                if (tradeType !== 'all') {
                    if (tradeType === 'international' && !route.is_international) return;
                    if (tradeType === 'domestic' && route.is_international) return;
                }
                
                // Add available years with quantity counts
                if (route.by_year) {
                    Object.entries(route.by_year).forEach(([y, data]) => {
                        // If year filter is active, only show that year
                        if (year !== 'all' && y !== year) return;
                        
                        let quantityCount = data.quantity || 0;
                        
                        // If commodity is selected, estimate quantity for that commodity in this year
                        if (targetCommodity && data.commodities && data.commodities[targetCommodity]) {
                            // Estimate by proportion: (commodity flows / total flows) * year quantity
                            const yearTotalFlows = Object.values(data.commodities).reduce((a, b) => a + b, 0);
                            const commodityFlows = data.commodities[targetCommodity];
                            quantityCount = yearTotalFlows > 0 ? (commodityFlows / yearTotalFlows) * quantityCount : 0;
                        } else if (targetCommodity) {
                            return; // This year doesn't have this commodity
                        }
                        
                        // If transport is selected, estimate quantity for that transport in this year
                        if (transport !== 'all' && data.transport_modes && data.transport_modes[transport]) {
                            // If both commodity and transport are selected, we approximate
                            if (!targetCommodity) {
                                const yearTotalFlows = Object.values(data.transport_modes).reduce((a, b) => a + b, 0);
                                const transportFlows = data.transport_modes[transport];
                                quantityCount = yearTotalFlows > 0 ? (transportFlows / yearTotalFlows) * (data.quantity || 0) : 0;
                            }
                        } else if (transport !== 'all') {
                            return; // This year doesn't have this transport mode
                        }
                        
                        const count = options.years.get(y) || 0;
                        options.years.set(y, count + quantityCount);
                    });
                }
            });
            
            // Calculate available commodities (considering other filters, but replacing commodity filter)
            routes.forEach(route => {
                if (transport !== 'all' && route.by_transport && !route.by_transport[transport]) return;
                if (year !== 'all' && route.by_year && !route.by_year[year]) return;
                if (ruralUrban !== 'all' && route.flow_type !== ruralUrban) return;
                if (tradeType !== 'all') {
                    if (tradeType === 'international' && !route.is_international) return;
                    if (tradeType === 'domestic' && route.is_international) return;
                }
                
                // Get the correct quantity based on year filter
                let totalQuantity = route.quantity || 0;
                if (year !== 'all' && route.by_year && route.by_year[year]) {
                    totalQuantity = route.by_year[year].quantity || 0;
                }
                
                // Get commodities from the appropriate source based on year and transport filters
                let commoditiesSource = route.by_commodity;
                
                // Priority: year filter takes precedence
                if (year !== 'all' && route.by_year && route.by_year[year]) {
                    // Use year-specific commodity data
                    // Estimate quantity by proportional allocation from by_commodity
                    commoditiesSource = { };
                    const yearData = route.by_year[year];
                    const yearQuantity = yearData.quantity || 0;
                    
                    if (yearData.commodities && route.by_commodity) {
                        // Calculate total flows in this year for proportion
                        const yearTotalFlows = Object.values(yearData.commodities).reduce((a, b) => a + b, 0);
                        
                        Object.entries(yearData.commodities).forEach(([comm, flows]) => {
                            // Estimate quantity by proportion: (flows in year / total flows in year) * year quantity
                            const estimatedQuantity = yearTotalFlows > 0 ? (flows / yearTotalFlows) * yearQuantity : 0;
                            commoditiesSource[comm] = { quantity: estimatedQuantity };
                        });
                    }
                } else if (transport !== 'all' && route.by_transport && route.by_transport[transport]) {
                    // Use transport-specific commodity data with actual quantity
                    commoditiesSource = { };
                    const transportData = route.by_transport[transport];
                    
                    if (transportData.commodities && route.by_commodity) {
                        Object.entries(transportData.commodities).forEach(([comm, flows]) => {
                            // Use actual quantity from by_commodity (this commodity is transported by this transport)
                            const actualQuantity = route.by_commodity[comm] ? (route.by_commodity[comm].quantity || 0) : 0;
                            commoditiesSource[comm] = { quantity: actualQuantity };
                        });
                    }
                }
                
                if (commoditiesSource && Object.keys(commoditiesSource).length > 0) {
                    // Route has commodity breakdown data
                    let commodityQuantitySum = 0;
                    Object.entries(commoditiesSource).forEach(([comm, data]) => {
                        const quantity = data.quantity || 0;
                        const count = options.commodities.get(comm) || 0;
                        options.commodities.set(comm, count + quantity);
                        commodityQuantitySum += quantity;
                    });
                    
                    // Add unclassified quantity (difference between total and commodity sum)
                    const unclassifiedQuantity = totalQuantity - commodityQuantitySum;
                    if (unclassifiedQuantity > 0) {
                        const unclassifiedCount = options.commodities.get('Unclassified') || 0;
                        options.commodities.set('Unclassified', unclassifiedCount + unclassifiedQuantity);
                    }
                } else {
                    // Route has no commodity data - add to "Unclassified" category
                    const unclassifiedCount = options.commodities.get('Unclassified') || 0;
                    options.commodities.set('Unclassified', unclassifiedCount + totalQuantity);
                }
            });
            
            // Calculate available transports (considering other filters, but replacing transport filter)
            routes.forEach(route => {
                const targetCommodity = commodity !== 'all' && route.by_commodity ? COMMODITY_MAP[commodity] : null;
                if (commodity !== 'all' && route.by_commodity) {
                    if (!targetCommodity || !route.by_commodity[targetCommodity]) return;
                }
                if (year !== 'all' && route.by_year && !route.by_year[year]) return;
                if (ruralUrban !== 'all' && route.flow_type !== ruralUrban) return;
                if (tradeType !== 'all') {
                    if (tradeType === 'international' && !route.is_international) return;
                    if (tradeType === 'domestic' && route.is_international) return;
                }
                
                // Get the correct quantity based on year filter
                let quantityCount = route.quantity || 0;
                if (year !== 'all' && route.by_year && route.by_year[year]) {
                    quantityCount = route.by_year[year].quantity || 0;
                }
                
                // Get transports from the appropriate source based on year and commodity filters
                let transportsSource = route.by_transport;
                
                // Priority: year filter takes precedence
                if (year !== 'all' && route.by_year && route.by_year[year]) {
                    // Use year-specific transport data
                    transportsSource = { };
                    const yearData = route.by_year[year];
                    if (yearData.transport_modes) {
                        Object.entries(yearData.transport_modes).forEach(([trans, flows]) => {
                            // year transport_modes only has flows, approximate quantity from route.by_transport
                            const transportQuantity = route.by_transport && route.by_transport[trans] ? 
                                route.by_transport[trans].quantity || 0 : flows;
                            transportsSource[trans] = { 
                                flows: flows,
                                quantity: transportQuantity
                            };
                        });
                    }
                } else if (targetCommodity && route.by_commodity && route.by_commodity[targetCommodity]) {
                    // Use commodity-specific transport data
                    transportsSource = { };
                    const commodityData = route.by_commodity[targetCommodity];
                    if (commodityData.transport_modes) {
                        Object.entries(commodityData.transport_modes).forEach(([trans, transData]) => {
                            // transport_modes stores full transport object {flow, quantity}
                            if (typeof transData === 'object') {
                                transportsSource[trans] = {
                                    flows: transData.flow || 0,
                                    quantity: transData.quantity || 0
                                };
                            } else {
                                // Fallback: if it's just a number, treat as flows
                                transportsSource[trans] = {
                                    flows: transData,
                                    quantity: transData
                                };
                            }
                        });
                    }
                }
                
                if (transportsSource && Object.keys(transportsSource).length > 0) {
                    // Route has transport breakdown data
                    Object.entries(transportsSource).forEach(([trans, data]) => {
                        const count = options.transports.get(trans) || 0;
                        // Use quantity for transport bars (to match other statistics)
                        const quantityToAdd = data.quantity || data.flows || 0;
                        options.transports.set(trans, count + quantityToAdd);
                    });
                } else {
                    // Route has no transport data - add to "Unknown" category
                    const unknownCount = options.transports.get('Unknown') || 0;
                    options.transports.set('Unknown', unknownCount + quantityCount);
                }
            });
            
            // Calculate rural-urban and trade types (considering ALL filters) - use quantity
            routes.forEach(route => {
                if (commodity !== 'all' && route.by_commodity) {
                    const targetCommodity = COMMODITY_MAP[commodity];
                    if (!targetCommodity || !route.by_commodity[targetCommodity]) return;
                }
                if (transport !== 'all' && route.by_transport && !route.by_transport[transport]) return;
                if (year !== 'all' && route.by_year && !route.by_year[year]) return;
                
                // Get the correct quantity based on year filter
                let quantityCount = route.quantity || 0;
                if (year !== 'all' && route.by_year && route.by_year[year]) {
                    quantityCount = route.by_year[year].quantity || 0;
                }
                
                const flowType = route.flow_type;
                if (flowType) {
                    // If ruralUrban filter is active, only show that type
                    if (ruralUrban !== 'all' && flowType !== ruralUrban) return;
                    
                    const count = options.ruralUrban.get(flowType) || 0;
                    options.ruralUrban.set(flowType, count + quantityCount);
                }
                
                const trade = route.is_international ? 'international' : 'domestic';
                
                // If tradeType filter is active, only show that type
                if (tradeType !== 'all' && trade !== tradeType) return;
                
                const tradeCount = options.tradeTypes.get(trade) || 0;
                options.tradeTypes.set(trade, tradeCount + quantityCount);
            });
            
            return options;
        }

        /**
         * Update interactive filter options in the UI
         */
        function updateInteractiveFilterOptions(availableOptions, currentFilters) {
            // Regenerate commodity and transport options with updated data
            generateCommodityCards(availableOptions.commodities);
            generateTransportBars(availableOptions.transports);
            
            // Restore active state for current selections
            restoreActiveState(currentFilters);
            
            // Update year filter
            updateYearFilterOptions(availableOptions.years);
            
            // Update rural-urban filter
            updateRuralUrbanFilterOptions(availableOptions.ruralUrban);
            
            // Update trade type filter
            updateTradeTypeFilterOptions(availableOptions.tradeTypes);
            
            // Ensure Color Mode options are always available (not constrained by other filters)
            ensureColorModeAlwaysAvailable();
        }

        /**
         * Restore active state after regenerating filter options
         */
        function restoreActiveState(currentFilters) {
            const { commodity, transport } = currentFilters;
            
            // Restore commodity active state
            if (commodity && commodity !== 'all') {
                const commodityCards = document.querySelectorAll('.commodity-card');
                commodityCards.forEach(card => {
                    card.classList.remove('active');
                    const nameEl = card.querySelector('.commodity-name');
                    if (nameEl) {
                        const name = nameEl.textContent.trim();
                        // Find if this card matches current selection
                        const dataName = COMMODITY_MAP[commodity];
                        if (dataName === name) {
                            card.classList.add('active');
                        }
                    }
                });
            }
            
            // Restore transport active state
            if (transport && transport !== 'all') {
                const transportBars = document.querySelectorAll('#transportBars .filter-bar-item');
                transportBars.forEach(bar => {
                    bar.classList.remove('active');
                    const labelEl = bar.querySelector('.filter-bar-label');
                    if (labelEl && labelEl.textContent.trim() === transport) {
                        bar.classList.add('active');
                    }
                });
            }
        }

        /**
         * Generate a stacked bar chart
         * @param {string} containerId - ID of the container for the bar chart
         * @param {string} legendId - ID of the container for the legend
         * @param {Map} dataMap - Map of values for the bar chart (key -> count)
         * @param {Map} allDataMap - Map of all available values for the legend (key -> count)
         * @param {Object} colorMap - Map of colors (key -> color)
         * @param {Object} labelMap - Map of labels (key -> label), optional
         * @param {string} selectedKey - Currently selected key
         * @param {Function} onSelect - Callback when segment is clicked
         * @param {boolean} sortByKey - If true, sort by key (e.g., years), otherwise by value
         */
        function generateStackedBarChart(containerId, legendId, dataMap, allDataMap, colorMap, labelMap, selectedKey, onSelect, sortByKey = false) {
            const container = document.getElementById(containerId);
            
            if (!container) return;
            
            // Calculate total from bar chart data
            const total = Array.from(dataMap.values()).reduce((a, b) => a + b, 0);
            if (total === 0) return;
            
            // Clear existing content
            container.innerHTML = '';
            
            // Generate bar segments from dataMap
            const sortedEntries = sortByKey 
                ? Array.from(dataMap.entries()).sort((a, b) => a[0].localeCompare(b[0]))  // Sort by key (for years)
                : Array.from(dataMap.entries()).sort((a, b) => b[1] - a[1]);              // Sort by value (for others)
            
            sortedEntries.forEach(([key, value]) => {
                const percentage = (value / total) * 100;
                const color = colorMap[key] || '#999';
                const label = labelMap ? labelMap[key] : key;
                const isSelected = selectedKey === key;
                
                // Get value from allDataMap for display
                const displayValue = allDataMap.get(key) || value;
                
                // Create bar segment - click toggles selection
                const segment = document.createElement('div');
                segment.className = `stacked-bar-segment ${isSelected ? 'selected' : ''}`;
                segment.style.width = `${percentage}%`;
                segment.style.backgroundColor = color;
                segment.onclick = () => {
                    // If already selected, deselect (return to 'all')
                    if (isSelected) {
                        onSelect('all');
                    } else {
                        onSelect(key);
                    }
                };
                
                // Add label with percentage if segment is wide enough
                if (percentage > 8) {
                    const labelEl = document.createElement('div');
                    labelEl.className = 'stacked-bar-label';
                    labelEl.innerHTML = `
                        <div class="stacked-bar-label-year">${label}</div>
                        <!-- <div class="stacked-bar-label-count">${formatCount(displayValue)}</div> -->
                        <div class="stacked-bar-label-count">${percentage.toFixed(1)}%</div>
                    `;
                    segment.appendChild(labelEl);
                } else if (percentage > 4) {
                    // For medium segments, show label and percentage only
                    const labelEl = document.createElement('div');
                    labelEl.className = 'stacked-bar-label';
                    labelEl.innerHTML = `
                        <div class="stacked-bar-label-year">${label}</div>
                        <div class="stacked-bar-label-count">${percentage.toFixed(0)}%</div>
                    `;
                    segment.appendChild(labelEl);
                } else if (percentage > 2) {
                    // For smaller segments, only show label
                    const labelEl = document.createElement('div');
                    labelEl.className = 'stacked-bar-label';
                    labelEl.innerHTML = `<div class="stacked-bar-label-year">${label}</div>`;
                    segment.appendChild(labelEl);
                }
                
                container.appendChild(segment);
            });
        }

        function updateYearFilterOptions(availableYears) {
            const yearFilter = document.getElementById('yearFilter');
            const selectedYear = yearFilter ? yearFilter.value : 'all';
            
            // Use filtered data for bar, global data for legend
            // This way: bar shows only current selection, legend shows all options
            
            generateStackedBarChart(
                'yearStackedBar',
                'yearLegend',
                availableYears,          // Filtered data for bar
                globalStats.years,       // All years for legend
                STACKED_BAR_COLORS,
                null, // Use keys as labels
                selectedYear === 'all' ? null : selectedYear,
                (year) => selectYearStat(null, year),
                true  // Sort by year (chronologically)
            );
        }


        function updateRuralUrbanFilterOptions(availableRuralUrban) {
            const ruralUrbanFilter = document.getElementById('ruralUrbanFilter');
            const selectedType = ruralUrbanFilter ? ruralUrbanFilter.value : 'all';
            
            // Use filtered data for bar, global data for legend
            
            generateStackedBarChart(
                'ruralUrbanStackedBar',
                'ruralUrbanLegend',
                availableRuralUrban,        // Filtered data for bar
                globalStats.ruralUrban,     // All types for legend
                STACKED_BAR_COLORS,
                FLOW_PATTERN_LABELS,
                selectedType === 'all' ? null : selectedType,
                (type) => selectRuralUrbanStat(null, type)
            );
        }

        function updateTradeTypeFilterOptions(availableTradeTypes) {
            const tradeTypeFilter = document.getElementById('tradeTypeFilter');
            const selectedType = tradeTypeFilter ? tradeTypeFilter.value : 'all';
            
            // Use filtered data for bar, global data for legend
            
            generateStackedBarChart(
                'tradeTypeStackedBar',
                'tradeTypeLegend',
                availableTradeTypes,        // Filtered data for bar
                globalStats.tradeTypes,     // All types for legend
                STACKED_BAR_COLORS,
                TRADE_TYPE_LABELS,
                selectedType === 'all' ? null : selectedType,
                (type) => selectTradeTypeStat(null, type)
            );
        }

        function updateRouteFilterBars(routeFilterStats) {
            // Get all route filter stat bars
            const routeFilterBars = document.querySelectorAll('.stats-chart .stat-bar');
            const routeBars = Array.from(routeFilterBars).filter(bar => 
                bar.getAttribute('onclick')?.includes('selectRouteFilterStat')
            );
            
            const maxCount = Math.max(...Object.values(routeFilterStats));
            
            routeBars.forEach(bar => {
                if (!bar) return;
                
                const labelEl = bar.querySelector('.stat-bar-label');
                if (!labelEl) return;
                
                const label = labelEl.textContent.trim();
                let filterType = label.toLowerCase();
                
                if (label === 'All') {
                    bar.style.height = '100%';
                    bar.style.opacity = '1';
                    bar.style.pointerEvents = 'auto';
                } else if (label === 'Top100') {
                    filterType = 'top100';
                    const count = routeFilterStats[filterType];
                    const percentage = Math.round((count / maxCount) * 100);
                    bar.style.height = `${Math.max(percentage, 5)}%`; // Minimum 5% for visibility
                    bar.style.opacity = '1';
                    bar.style.pointerEvents = 'auto';
                } else if (routeFilterStats[filterType]) {
                    const count = routeFilterStats[filterType];
                    const percentage = Math.round((count / maxCount) * 100);
                    bar.style.height = `${percentage}%`;
                    bar.style.opacity = '1';
                    bar.style.pointerEvents = 'auto';
                }
            });
        }

        function updateColorModeBars(ruralUrbanStats, tradeTypeStats) {
            const colorModeBars = document.querySelectorAll('.color-mode-bar');
            
            colorModeBars.forEach(bar => {
                if (!bar) return;
                
                const mode = bar.getAttribute('data-mode');
                const barFill = bar.querySelector('.bar-fill');
                const barValue = bar.querySelector('.bar-value');
                
                if (!barFill || !barValue) return;
                
                if (mode === 'source_destination') {
                    // Source-Destination mode shows all data
                    barFill.style.width = '100%';
                    barValue.textContent = 'Default';
                } else if (mode === 'rural_urban') {
                    // Rural-Urban mode shows dominant rural-urban flow
                    const total = Array.from(ruralUrbanStats.values()).reduce((a, b) => a + b, 0);
                    const ruralToUrban = ruralUrbanStats.get('rural_to_urban') || 0;
                    if (total > 0) {
                        const percentage = Math.round((ruralToUrban / total) * 100);
                        barFill.style.width = `${percentage}%`;
                        barValue.textContent = `R→U ${percentage}%`;
                    }
                } else if (mode === 'international') {
                    // International mode shows international percentage
                    const total = Array.from(tradeTypeStats.values()).reduce((a, b) => a + b, 0);
                    const international = tradeTypeStats.get('international') || 0;
                    if (total > 0) {
                        const percentage = Math.round((international / total) * 100);
                        barFill.style.width = `${percentage}%`;
                        barValue.textContent = `Intl ${percentage}%`;
                    }
                }
            });
        }

        function formatCount(count) {
            if (count >= 1000) {
                return (count / 1000).toFixed(1) + 'K';
            }
            return count.toString();
        }

        function formatQuantity(num) {
            if (num >= 1000000000) {
                return (num / 1000000000).toFixed(1) + 'B';
            } else if (num >= 1000000) {
                return (num / 1000000).toFixed(0) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(0) + 'K';
            }
            return Math.round(num).toString();
        }

        /**
         * Ensure Color Mode options are always available (not constrained by other filters)
         */
        function ensureColorModeAlwaysAvailable() {
            const allControlGroups = document.querySelectorAll('.control-group');
            allControlGroups.forEach(group => {
                const label = group.querySelector('label');
                if (label && label.textContent.trim() === 'Color Mode') {
                    const colorModeBars = group.querySelectorAll('.filter-bar-item');
                    colorModeBars.forEach(bar => {
                        bar.style.opacity = '1';
                        bar.style.pointerEvents = 'auto';
                    });
                }
            });
        }

        function filterAndUpdate() {
            // Get values from either interactive or traditional mode
            const yearFilter = document.getElementById('yearFilter');
            const commodityFilter = document.getElementById('commodityFilter');
            const transportFilter = document.getElementById('transportFilter');
            const ruralUrbanFilter = document.getElementById('ruralUrbanFilter');
            const tradeTypeFilter = document.getElementById('tradeTypeFilter');
            
            const year = yearFilter ? yearFilter.value : 'all';
            const commodity = commodityFilter ? commodityFilter.value : 'all';
            const transport = transportFilter ? transportFilter.value : 'all';
            const ruralUrban = ruralUrbanFilter ? ruralUrbanFilter.value : 'all';
            const tradeType = tradeTypeFilter ? tradeTypeFilter.value : 'all';
            
            // Update filter options based on current selections (constraints)
            updateFilterOptions({ year, commodity, transport, ruralUrban, tradeType });
            
            if (currentDataSource === 'heatmap') {
                // For heatmap: filter routes first, then generate heatmap from filtered data
                const filters = { year, commodity, transport };
                
                let routesToAggregate = allRoutesFlat.map(route => {
                    // Apply rural-urban filter (works in all color modes)
                    if (ruralUrban !== 'all' && route.flow_type !== ruralUrban) {
                        return null;
                    }
                    
                    // Apply international-domestic filter (works in all color modes)
                    if (tradeType !== 'all') {
                        if (tradeType === 'international' && !route.is_international) return null;
                        if (tradeType === 'domestic' && route.is_international) return null;
                    }
                    
                    // Get precise display data based on filters
                    const displayData = getRouteDisplayData(route, filters);
                    if (!displayData) return null; // Route doesn't match filters
                    
                    // Attach display data to route for aggregation
                    return {
                        ...route,
                        _displayData: displayData
                    };
                }).filter(r => r !== null);
                
                // Store filtered routes info for stats (before aggregation)
                window.heatmapSourceRoutes = routesToAggregate;
                
                // Generate heatmap from filtered routes
                filteredRoutes = generateHeatmapFromRoutes(routesToAggregate);
            } else {
                // For other modes: standard route filtering
                let data = getFilteredDataBySource(currentDataSource);
                const filters = { year, commodity, transport };
                
                filteredRoutes = data.map(route => {
                    // Apply rural-urban filter (works in all color modes)
                    if (ruralUrban !== 'all' && route.flow_type !== ruralUrban) {
                        return null;
                    }
                    
                    // Apply international-domestic filter (works in all color modes)
                    if (tradeType !== 'all') {
                        if (tradeType === 'international' && !route.is_international) return null;
                        if (tradeType === 'domestic' && route.is_international) return null;
                    }
                    
                    // Get precise display data based on filters
                    const displayData = getRouteDisplayData(route, filters);
                    if (!displayData) return null; // Route doesn't match filters
                    
                    // Attach display data to route for use in visualization
                    return {
                        ...route,
                        _displayData: displayData
                    };
                }).filter(r => r !== null);
            }

            updateStats();
            updateVisualization();
        }

        function updateStats() {
            if (currentDataSource === 'heatmap') {
                // Update labels for heatmap mode
                document.getElementById('routesLabel').textContent = 'Routes';
                document.getElementById('distanceLabel').textContent = 'Grid Points';
                
                // Show stats from filtered routes (before aggregation to grid)
                const sourceRoutes = window.heatmapSourceRoutes || [];
                
                // Total routes used to generate heatmap
                document.getElementById('visibleRoutes').textContent = sourceRoutes.length.toLocaleString();
                
                // Total quantity from filtered routes
                const totalQuantity = sourceRoutes.reduce((sum, r) => {
                    const quantity = r._displayData ? (r._displayData.quantity || 0) : (r.quantity || 0);
                    return sum + quantity;
                }, 0);
                document.getElementById('totalFlows').textContent = formatQuantity(totalQuantity);
                
                // International flows count
                const intlCount = sourceRoutes.filter(r => r.is_international).length;
                document.getElementById('intlFlows').textContent = intlCount.toLocaleString();
                
                // Grid points generated
                document.getElementById('avgDistance').textContent = filteredRoutes.length.toLocaleString();
                
                return;
            }
            
            // Reset labels for non-heatmap modes
            document.getElementById('routesLabel').textContent = 'Routes';
            document.getElementById('distanceLabel').textContent = 'Avg Distance';

            // Use precise quantity from _displayData
            const totalQuantity = filteredRoutes.reduce((sum, r) => {
                const quantity = r._displayData ? (r._displayData.quantity || 0) : (r.quantity || 0);
                return sum + quantity;
            }, 0);
            const totalFlows = filteredRoutes.reduce((sum, r) => {
                const flows = r._displayData ? r._displayData.flows : r.flows;
                return sum + (flows || 0);
            }, 0);
            const intlCount = filteredRoutes.filter(r => r.is_international).length;
            
            // Calculate average distance
            let totalDistance = 0;
            let count = 0;
            filteredRoutes.forEach(r => {
                if (r.source && r.destination && r.source.coordinates && r.destination.coordinates) {
                    const [lon1, lat1] = r.source.coordinates;
                    const [lon2, lat2] = r.destination.coordinates;
                    const dist = calculateDistance(lat1, lon1, lat2, lon2);
                    totalDistance += dist;
                    count++;
                }
            });
            const avgDist = count > 0 ? Math.round(totalDistance / count) : 0;

            document.getElementById('visibleRoutes').textContent = filteredRoutes.length.toLocaleString();
            document.getElementById('totalFlows').textContent = formatQuantity(totalQuantity);
            document.getElementById('intlFlows').textContent = intlCount.toLocaleString();
            document.getElementById('avgDistance').textContent = avgDist + ' km';
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        function getFlowTypeColor(route) {
            if (colorMode === 'rural_urban' && route.flow_type) {
                // Rural-Urban color scheme (legacy, for reference)
                const colors = {
                    'rural_to_urban': [46, 204, 113],    // Green - Rural supplies Urban
                    'urban_to_rural': [52, 152, 219],    // Blue - Urban supplies Rural
                    'rural_to_rural': [241, 196, 15],    // Yellow - Rural to Rural flows
                    'urban_to_urban': [155, 89, 182]     // Purple - Urban to Urban flows
                };
                return colors[route.flow_type] || [200, 200, 200];
            } else {
                // International-Domestic color scheme
                return route.is_international ? [229, 62, 62] : [49, 130, 206];
            }
        }

        // Get color based on location type (Urban = yellow, Rural = blue)
        function getLocationColor(isUrban) {
            if (isUrban) {
                return [251, 232, 25]; // #FBE819 Yellow for urban
            } else {
                return [42, 80, 234]; // #2A50EA Blue for rural
            }
        }

        // Get color based on point type (Source = green, Destination = red)
        function getPointTypeColor(isSource) {
            if (isSource) {
                return [16, 185, 129]; // #10b981 Green for source
            } else {
                return [239, 68, 68]; // #ef4444 Red for destination
            }
        }

        function updateVisualization() {
            if (!deckgl) return; // Ensure deckgl is initialized
            
            const arcWidth = parseFloat(document.getElementById('arcWidth').value);
            const showPoints = document.getElementById('showPoints').checked;
            const showViaCity = document.getElementById('showViaCity').checked;

            const layers = [];

            if (currentDataSource === 'heatmap') {
                // Heatmap layer
                const heatmapLayer = new HeatmapLayer({
                    id: 'heatmap-layer',
                    data: filteredRoutes,
                    getPosition: d => d.coordinates,
                    getWeight: d => d.weight,
                    radiusPixels: 60,
                    intensity: 1,
                    threshold: 0.05
                });
                layers.push(heatmapLayer);

            } else {
                // Separate routes with OSRM paths from those without
                const routesWithPaths = filteredRoutes.filter(r => r.path && r.path.length > 0);
                const routesWithoutPaths = filteredRoutes.filter(r => !r.path || r.path.length === 0);
                
                // PathLayer for routes with OSRM paths (real road routing)
                const pathLayer = new PathLayer({
                    id: 'path-layer',
                    data: routesWithPaths,
                    getPath: d => d.path,
                    getColor: d => {
                        // Check if this route should be highlighted
                        let isHighlighted = true;
                        
                        // Priority 1: Point selection
                        if (selectedPoint) {
                            if (selectedPoint.type === 'source') {
                                const srcCoords = d.source.coordinates;
                                isHighlighted = (
                                    srcCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                    srcCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                );
                            } else if (selectedPoint.type === 'destination') {
                                const destCoords = d.destination.coordinates;
                                isHighlighted = (
                                    destCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                    destCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                );
                            }
                        }
                        // Priority 2: Route selection
                        else if (selectedRoute) {
                            isHighlighted = (d.source.name === selectedRoute.source.name && 
                                           d.destination.name === selectedRoute.destination.name);
                        }
                        // Priority 3: Hover
                        else if (hoveredRoute) {
                            isHighlighted = (d.source.name === hoveredRoute.source.name && 
                                           d.destination.name === hoveredRoute.destination.name);
                        }
                        
                        if (colorMode === 'rural_urban') {
                            const color = getLocationColor(d.source.is_urban);
                            const alpha = isHighlighted ? 200 : 30;
                            return [color[0], color[1], color[2], alpha];
                        } else if (colorMode === 'source_destination') {
                            const color = [100, 180, 255]; // Blue for paths
                            const alpha = isHighlighted ? 200 : 40;
                            return [color[0], color[1], color[2], alpha];
                        } else {
                            const color = getFlowTypeColor(d);
                            const alpha = isHighlighted ? 255 : 40;
                            return [color[0], color[1], color[2], alpha];
                        }
                    },
                    getWidth: d => {
                        // Use quantity instead of flows for width
                        const quantity = d.quantity || d.flows || 1;
                        const baseWidth = Math.sqrt(quantity) * 0.15;  // Reduced from 0.5 to 0.15
                        let isHighlighted = false;
                        
                        if (selectedPoint) {
                            if (selectedPoint.type === 'source') {
                                const srcCoords = d.source.coordinates;
                                isHighlighted = (
                                    srcCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                    srcCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                );
                            } else if (selectedPoint.type === 'destination') {
                                const destCoords = d.destination.coordinates;
                                isHighlighted = (
                                    destCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                    destCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                );
                            }
                        } else if (selectedRoute) {
                            isHighlighted = (d.source.name === selectedRoute.source.name && 
                                           d.destination.name === selectedRoute.destination.name);
                        } else if (hoveredRoute) {
                            isHighlighted = (d.source.name === hoveredRoute.source.name && 
                                           d.destination.name === hoveredRoute.destination.name);
                        }
                        
                        return isHighlighted ? baseWidth * 3 : baseWidth;
                    },
                    widthMinPixels: 0.5,
                    widthMaxPixels: 10,
                    pickable: true,
                    onHover: info => {
                        if (info.object && !selectedRoute && !selectedPoint) {
                            hoveredRoute = info.object;
                        } else if (!info.object) {
                            hoveredRoute = null;
                        }
                    },
                    updateTriggers: {
                        getColor: [hoveredRoute, selectedRoute, selectedPoint, colorMode],
                        getWidth: [hoveredRoute, selectedRoute, selectedPoint]
                    }
                });
                layers.push(pathLayer);
                
                // Arc layer for routes without OSRM paths (fallback to straight lines)
                let arcData = routesWithoutPaths;
                
                // If showViaCity is enabled, create two-segment routes
                if (showViaCity) {
                    arcData = [];
                    routesWithoutPaths.forEach(route => {
                        if (route.via_city && route.via_city.coordinates) {
                            // First segment: source → via_city
                            arcData.push({
                                ...route,
                                _segment: 'first',
                                _targetPos: route.via_city.coordinates
                            });
                            // Second segment: via_city → destination
                            arcData.push({
                                ...route,
                                _segment: 'second',
                                _sourcePos: route.via_city.coordinates
                            });
                        } else {
                            // No via_city, keep as direct route
                            arcData.push(route);
                        }
                    });
                }
                
                const arcLayer = new ArcLayer({
                    id: 'arc-layer',
                    data: arcData,
                    getSourcePosition: d => d._sourcePos || d.source.coordinates,
                    getTargetPosition: d => d._targetPos || d.destination.coordinates,
                    getSourceColor: d => {
                        // Check if this route should be highlighted
                        let isHighlighted = true;
                        
                        // Priority 1: Point selection (compare by coordinates)
                        if (selectedPoint) {
                            if (selectedPoint.type === 'source') {
                                const srcCoords = d.source.coordinates;
                                isHighlighted = (
                                    srcCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                    srcCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                );
                            } else if (selectedPoint.type === 'destination') {
                                const destCoords = d.destination.coordinates;
                                isHighlighted = (
                                    destCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                    destCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                );
                            }
                        }
                        // Priority 2: Route selection
                        else if (selectedRoute) {
                            isHighlighted = (d.source.name === selectedRoute.source.name && 
                                           d.destination.name === selectedRoute.destination.name);
                        }
                        // Priority 3: Hover
                        else if (hoveredRoute) {
                            isHighlighted = (d.source.name === hoveredRoute.source.name && 
                                           d.destination.name === hoveredRoute.destination.name);
                        }
                        
                        if (colorMode === 'rural_urban') {
                            const color = getLocationColor(d.source.is_urban);
                            const alpha = isHighlighted ? 180 : 3;
                            return [color[0], color[1], color[2], alpha];
                        } else if (colorMode === 'source_destination') {
                            const color = getPointTypeColor(true);
                            const alpha = isHighlighted ? 200 : 5;
                            return [color[0], color[1], color[2], alpha];
                        } else {
                            const color = getFlowTypeColor(d);
                            const alpha = isHighlighted ? 255 : 5;
                            return [color[0], color[1], color[2], alpha];
                        }
                    },
                    getTargetColor: d => {
                        // Check if this route should be highlighted
                        let isHighlighted = true;
                        
                        // Priority 1: Point selection (compare by coordinates)
                        if (selectedPoint) {
                            if (selectedPoint.type === 'source') {
                                const srcCoords = d.source.coordinates;
                                isHighlighted = (
                                    srcCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                    srcCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                );
                            } else if (selectedPoint.type === 'destination') {
                                const destCoords = d.destination.coordinates;
                                isHighlighted = (
                                    destCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                    destCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                );
                            }
                        }
                        // Priority 2: Route selection
                        else if (selectedRoute) {
                            isHighlighted = (d.source.name === selectedRoute.source.name && 
                                           d.destination.name === selectedRoute.destination.name);
                        }
                        // Priority 3: Hover
                        else if (hoveredRoute) {
                            isHighlighted = (d.source.name === hoveredRoute.source.name && 
                                           d.destination.name === hoveredRoute.destination.name);
                        }
                        
                        if (colorMode === 'rural_urban') {
                            const color = getLocationColor(d.destination.is_urban);
                            const alpha = isHighlighted ? 60 : 2;
                            return [color[0], color[1], color[2], alpha];
                        } else if (colorMode === 'source_destination') {
                            const color = getPointTypeColor(false);
                            const alpha = isHighlighted ? 80 : 3;
                            return [color[0], color[1], color[2], alpha];
                        } else {
                            const color = getFlowTypeColor(d);
                            const alpha = isHighlighted ? 60 : 3;
                            return [color[0], color[1], color[2], alpha];
                        }
                    },
                    getWidth: d => {
                        // Use precise quantity from _displayData if available
                        const quantity = d._displayData ? (d._displayData.quantity || d._displayData.flows) : (d.quantity || d.flows || 1);
                        return Math.log(quantity + 1) * arcWidth * 0.6;  // Additional 0.6 multiplier to make lines thinner
                    },
                    pickable: true,
                    autoHighlight: false, // Disable auto-highlight, we handle it manually
                    onHover: handleHover,
                    onClick: handleClick,
                    updateTriggers: {
                        getWidth: arcWidth,  // Force recalculation when arcWidth changes
                        getSourceColor: [colorMode, hoveredRoute, selectedRoute, selectedPoint],  // Update when hover/select changes
                        getTargetColor: [colorMode, hoveredRoute, selectedRoute, selectedPoint]   // Update when hover/select changes
                    }
                });
                layers.push(arcLayer);

                // Points layer - icons for source (▲) and destination (▼)
                if (showPoints) {
                    const sourcePointsMap = new Map();
                    const destPointsMap = new Map();
                    
                    // Collect all unique points BY COORDINATES (not by name)
                    filteredRoutes.forEach(r => {
                        if (r.source && r.source.coordinates) {
                            // Use coordinates as key (rounded to 3 decimals ≈ 111m precision)
                            const coords = r.source.coordinates;
                            const key = `${coords[0].toFixed(3)}_${coords[1].toFixed(3)}`;
                            
                            if (!sourcePointsMap.has(key)) {
                                sourcePointsMap.set(key, {
                                    position: coords,
                                    type: 'source',
                                    name: r.source.name,  // First encountered name
                                    country: r.source.country,
                                    is_urban: r.source.is_urban,
                                    routes: []
                                });
                            }
                            sourcePointsMap.get(key).routes.push(r);
                        }
                        if (r.destination && r.destination.coordinates) {
                            // Use coordinates as key
                            const coords = r.destination.coordinates;
                            const key = `${coords[0].toFixed(3)}_${coords[1].toFixed(3)}`;
                            
                            if (!destPointsMap.has(key)) {
                                destPointsMap.set(key, {
                                    position: coords,
                                    type: 'destination',
                                    name: r.destination.name,  // First encountered name
                                    country: r.destination.country,
                                    is_urban: r.destination.is_urban,
                                    routes: []
                                });
                            }
                            destPointsMap.get(key).routes.push(r);
                        }
                    });
                    
                    const sourcePoints = Array.from(sourcePointsMap.values());
                    const destPoints = Array.from(destPointsMap.values());

                    // Icon mapping for triangles
                    const ICON_MAPPING = {
                        triangle_up: {x: 0, y: 0, width: 128, height: 128, mask: true},
                        triangle_down: {x: 0, y: 0, width: 128, height: 128, mask: true}
                    };

                    // Source icons layer (▲ rendered first, appears below)
                    const sourceLayer = new IconLayer({
                        id: 'source-icons-layer',
                        data: sourcePoints,
                        getPosition: d => d.position,
                        getIcon: d => 'triangle_up',
                        getColor: d => {
                            // Check if this point should be highlighted
                            let isHighlighted = true;
                            
                            // Priority 1: Point selection (compare by coordinates)
                            if (selectedPoint) {
                                if (selectedPoint.type === 'source') {
                                    // Highlight this source point if it matches selected coordinates
                                    const pointCoords = d.position;
                                    isHighlighted = (
                                        pointCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                        pointCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                    ) || (d.routes && d.routes.some(r => {
                                        const srcCoords = r.source.coordinates;
                                        return srcCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                               srcCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3);
                                    }));
                                } else if (selectedPoint.type === 'destination') {
                                    // Highlight source points that have routes to selected destination coordinates
                                    isHighlighted = d.routes && d.routes.some(r => {
                                        const destCoords = r.destination.coordinates;
                                        return destCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                               destCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3);
                                    });
                                }
                            }
                            // Priority 2: Route selection
                            else if (selectedRoute) {
                                isHighlighted = d.routes && d.routes.some(r => 
                                    r.source.name === selectedRoute.source.name && 
                                    r.destination.name === selectedRoute.destination.name
                                );
                            }
                            // Priority 3: Hover
                            else if (hoveredRoute) {
                                isHighlighted = d.routes && d.routes.some(r => 
                                    r.source.name === hoveredRoute.source.name && 
                                    r.destination.name === hoveredRoute.destination.name
                                );
                            }
                            
                            // Color based on mode
                            let color;
                            if (colorMode === 'rural_urban') {
                                color = getLocationColor(d.is_urban);
                            } else if (colorMode === 'source_destination') {
                                color = getPointTypeColor(true); // true = source
                            } else {
                                // International mode: use source/dest color scheme
                                color = getPointTypeColor(true); // true = source
                            }
                            const alpha = isHighlighted ? 200 : 5;
                            return [color[0], color[1], color[2], alpha];
                        },
                        getSize: 22, // Unified size for hexagon effect
                        sizeMinPixels: 7,
                        sizeMaxPixels: 30,
                        iconAtlas: 'data:image/svg+xml;base64,' + btoa(`
                            <svg width="128" height="128" xmlns="http://www.w3.org/2000/svg">
                                <path d="M 64 28 L 102 88 L 26 88 Z" fill="white" stroke="rgba(0,0,0,0.3)" stroke-width="3"/>
                            </svg>
                        `),
                        iconMapping: ICON_MAPPING,
                        pickable: true,
                        onHover: handleHover,
                        onClick: handleClick,
                        updateTriggers: {
                            getColor: [colorMode, hoveredRoute, selectedRoute, selectedPoint]
                        }
                    });
                    layers.push(sourceLayer);

                    // Destination icons layer (▼ rendered second, appears on top, same size for hexagon)
                    const destLayer = new IconLayer({
                        id: 'dest-icons-layer',
                        data: destPoints,
                        getPosition: d => d.position,
                        getIcon: d => 'triangle_down',
                        getColor: d => {
                            // Check if this point should be highlighted
                            let isHighlighted = true;
                            
                            // Priority 1: Point selection (compare by coordinates)
                            if (selectedPoint) {
                                if (selectedPoint.type === 'destination') {
                                    // Highlight this destination point if it matches selected coordinates
                                    const pointCoords = d.position;
                                    isHighlighted = (
                                        pointCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                        pointCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3)
                                    ) || (d.routes && d.routes.some(r => {
                                        const destCoords = r.destination.coordinates;
                                        return destCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                               destCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3);
                                    }));
                                } else if (selectedPoint.type === 'source') {
                                    // Highlight destination points that receive routes from selected source coordinates
                                    isHighlighted = d.routes && d.routes.some(r => {
                                        const srcCoords = r.source.coordinates;
                                        return srcCoords[0].toFixed(3) === selectedPoint.position[0].toFixed(3) &&
                                               srcCoords[1].toFixed(3) === selectedPoint.position[1].toFixed(3);
                                    });
                                }
                            }
                            // Priority 2: Route selection
                            else if (selectedRoute) {
                                isHighlighted = d.routes && d.routes.some(r => 
                                    r.source.name === selectedRoute.source.name && 
                                    r.destination.name === selectedRoute.destination.name
                                );
                            }
                            // Priority 3: Hover
                            else if (hoveredRoute) {
                                isHighlighted = d.routes && d.routes.some(r => 
                                    r.source.name === hoveredRoute.source.name && 
                                    r.destination.name === hoveredRoute.destination.name
                                );
                            }
                            
                            // Color based on mode
                            let color;
                            if (colorMode === 'rural_urban') {
                                color = getLocationColor(d.is_urban);
                            } else if (colorMode === 'source_destination') {
                                color = getPointTypeColor(false); // false = destination
                            } else {
                                // International mode: use source/dest color scheme
                                color = getPointTypeColor(false); // false = destination
                            }
                            const alpha = isHighlighted ? 200 : 5;
                            return [color[0], color[1], color[2], alpha];
                        },
                        getSize: 22, // Same size as source for perfect hexagon
                        sizeMinPixels: 7,
                        sizeMaxPixels: 30,
                        iconAtlas: 'data:image/svg+xml;base64,' + btoa(`
                            <svg width="128" height="128" xmlns="http://www.w3.org/2000/svg">
                                <path d="M 64 100 L 26 40 L 102 40 Z" fill="white" stroke="rgba(0,0,0,0.3)" stroke-width="3"/>
                            </svg>
                        `),
                        iconMapping: ICON_MAPPING,
                        pickable: true,
                        onHover: handleHover,
                        onClick: handleClick,
                        updateTriggers: {
                            getColor: [colorMode, hoveredRoute, selectedRoute, selectedPoint]
                        }
                    });
                    layers.push(destLayer);
                }

                // Via city visualization (elevated spheres + vertical lines)
                if (showViaCity) {
                    // Extract unique via cities from filtered routes
                    const viaCityMap = new Map();
                    filteredRoutes.forEach(r => {
                        if (r.via_city && r.via_city.coordinates) {
                            const key = r.via_city.name;
                            if (!viaCityMap.has(key)) {
                                viaCityMap.set(key, {
                                    name: r.via_city.name,
                                    coordinates: r.via_city.coordinates,
                                    routeCount: 0
                                });
                            }
                            viaCityMap.get(key).routeCount++;
                        }
                    });
                    const viaCityPoints = Array.from(viaCityMap.values());

                    // City color mapping
                    const cityColors = {
                        'Bamako': [255, 165, 0],      // Orange
                        'Tamale': [46, 204, 113],     // Green
                        'Ouagadougou': [52, 152, 219], // Blue
                        'Bamenda': [155, 89, 182]      // Purple
                    };

                    // Elevated sphere layer for via cities
                    const viaCitySphereLayer = new deck.ScatterplotLayer({
                        id: 'via-city-spheres',
                        data: viaCityPoints,
                        getPosition: d => [...d.coordinates, 500], // Elevated 500m
                        getRadius: 25000, // Larger than source/dest points
                        getFillColor: d => {
                            const color = cityColors[d.name] || [255, 165, 0];
                            return [...color, 200]; // Semi-transparent
                        },
                        stroked: true,
                        getLineColor: d => {
                            const color = cityColors[d.name] || [255, 165, 0];
                            return [...color, 255];
                        },
                        lineWidthMinPixels: 2,
                        pickable: true,
                        onHover: handleHover
                    });
                    layers.push(viaCitySphereLayer);

                    // Vertical line layer from sphere to ground
                    const viaCityLineLayer = new deck.LineLayer({
                        id: 'via-city-lines',
                        data: viaCityPoints,
                        getSourcePosition: d => [...d.coordinates, 500], // Top (sphere)
                        getTargetPosition: d => [...d.coordinates, 0],   // Ground
                        getColor: d => {
                            const color = cityColors[d.name] || [255, 165, 0];
                            return [...color, 200]; // More opaque
                        },
                        getWidth: 5, // Thicker line
                        widthMinPixels: 3
                    });
                    layers.push(viaCityLineLayer);
                }
            }

            deckgl.setProps({ layers });
        }

        function handleClick(info) {
            if (info.object && info.object.source && info.object.destination) {
                // Clicked on a route (arc)
                const clickedRoute = info.object._segment ? 
                    filteredRoutes.find(r => 
                        r.source.name === info.object.source.name && 
                        r.destination.name === info.object.destination.name
                    ) : info.object;
                
                // Toggle route selection, clear point selection
                selectedPoint = null;
                if (selectedRoute === clickedRoute) {
                    selectedRoute = null;
                } else {
                    selectedRoute = clickedRoute;
                }
                updateVisualization();
                
            } else if (info.object && info.object.position && info.object.type) {
                // Clicked on a point (source or destination)
                const clickedPoint = {
                    position: info.object.position,
                    type: info.object.type
                };
                
                // Toggle point selection, clear route selection
                selectedRoute = null;
                if (selectedPoint && 
                    selectedPoint.position[0] === clickedPoint.position[0] && 
                    selectedPoint.position[1] === clickedPoint.position[1] && 
                    selectedPoint.type === clickedPoint.type) {
                    selectedPoint = null; // Deselect if clicking same point
            } else {
                    selectedPoint = clickedPoint;
                }
                updateVisualization();
                
            } else {
                // Click on empty space - clear all selections
                if (selectedRoute || selectedPoint) {
                    selectedRoute = null;
                    selectedPoint = null;
                    updateVisualization();
                }
            }
        }

        function handleHover(info) {
            const tooltip = document.getElementById('tooltip');
            
            // Update hovered route for highlighting
            if (info.object && info.object.source && info.object.destination) {
                // Get the original route (not the segment)
                hoveredRoute = info.object._segment ? 
                    filteredRoutes.find(r => 
                        r.source.name === info.object.source.name && 
                        r.destination.name === info.object.destination.name
                    ) : info.object;
                updateVisualization();
            } else if (!info.object && !selectedRoute) {
                // Only clear hover if nothing is selected
                if (hoveredRoute) {
                    hoveredRoute = null;
                    updateVisualization();
                }
            }
            
            if (info.object) {
                const obj = info.object;
                let html = '';

                if (obj.source && obj.destination) {
                    // Arc (route) tooltip - use _displayData for precise values
                    const displayData = obj._displayData || obj;
                    
                    // Build title with via_city
                    let titlePrefix = '';
                    if (colorMode === 'rural_urban') {
                        const sourceIcon = obj.source.is_urban ? '🏙️' : '🏘️';
                        const destIcon = obj.destination.is_urban ? '🏙️' : '🏘️';
                        
                        // Show three-point route with via_city
                        if (obj.via_city && obj.via_city.name) {
                            titlePrefix = `${sourceIcon} ${obj.source.name} → ${obj.via_city.name} → ${destIcon} ${obj.destination.name}`;
                        } else {
                            titlePrefix = `${sourceIcon} ${obj.source.name} → ${destIcon} ${obj.destination.name}`;
                        }
                    } else if (colorMode === 'source_destination') {
                        // Show with source/destination icons
                        if (obj.via_city && obj.via_city.name) {
                            titlePrefix = `📤 ${obj.source.name} → ${obj.via_city.name} → 📥 ${obj.destination.name}`;
                        } else {
                            titlePrefix = `📤 ${obj.source.name} → 📥 ${obj.destination.name}`;
                        }
                    } else {
                        // Show three-point route
                        if (obj.via_city && obj.via_city.name) {
                            titlePrefix = `${obj.source.name} → ${obj.via_city.name} → ${obj.destination.name}`;
                        } else {
                            titlePrefix = `${obj.source.name} → ${obj.destination.name}`;
                        }
                    }
                    
                    html = `
                        <div class="tooltip-title">${titlePrefix}</div>
                        <div class="tooltip-item">📦 Quantity: ${(displayData.quantity || 0).toLocaleString()}</div>
                        <div class="tooltip-item">🔄 Flows: ${(displayData.flows || 0).toLocaleString()}</div>
                    `;
                    
                    // Show year range if multiple years
                    if (displayData.years && displayData.years.length > 0) {
                        const yearDisplay = displayData.years.length === 1 
                            ? displayData.years[0]
                            : `${Math.min(...displayData.years)}-${Math.max(...displayData.years)}`;
                        html += `<div class="tooltip-item">📅 Year: ${yearDisplay}</div>`;
                    }
                    
                    // Show flow type based on color mode
                    if (colorMode === 'rural_urban' && obj.flow_type_label) {
                        html += `<div class="tooltip-item">🔀 ${obj.flow_type_label}</div>`;
                    } else if (colorMode === 'international') {
                        html += `<div class="tooltip-item">${obj.is_international ? '🌐 International' : '🏠 Domestic'}</div>`;
                    } else if (colorMode === 'source_destination') {
                        html += `<div class="tooltip-item">📤 Source → 📥 Destination</div>`;
                    }
                    
                    html += `<div class="tooltip-item">📍 ${obj.source.country} → ${obj.destination.country}</div>`;
                    
                    // Show main transportation mode from displayData
                    if (displayData.main_transport) {
                        html += `<div class="tooltip-item">🚗 ${displayData.main_transport}</div>`;
                    }
                    
                    // Show commodities from displayData (precise for filters)
                    if (displayData.commodities) {
                        const commodities = displayData.commodities;
                        const commList = Object.entries(commodities).slice(0, 3)
                            .map(([name, count]) => `${name} (${count})`)
                            .join(', ');
                        html += `<div class="tooltip-commodities">📦 ${commList}</div>`;
                    }
                } else if (obj.name) {
                    // Point tooltip (source, destination, or via_city)
                    if (obj.routeCount !== undefined) {
                        // Via city point
                        html = `
                            <div class="tooltip-title">🏙️ ${obj.name}</div>
                            <div class="tooltip-item">Transit City</div>
                            <div class="tooltip-item">🔄 ${obj.routeCount} routes pass through</div>
                        `;
                    } else {
                        // Source or destination point
                        const urbanStatus = obj.is_urban !== undefined ? (obj.is_urban ? '🏙️ Urban' : '🏘️ Rural') : '';
                        const pointTypeLabel = obj.type === 'source' ? '📤 Source' : '📥 Destination';
                        html = `
                            <div class="tooltip-title">${obj.name}</div>
                            <div class="tooltip-item">📍 ${obj.country}</div>
                            ${urbanStatus && colorMode === 'rural_urban' ? `<div class="tooltip-item">${urbanStatus}</div>` : ''}
                            <div class="tooltip-item">${pointTypeLabel}</div>
                        `;
                    }
                }

                tooltip.innerHTML = html;
                tooltip.style.display = 'block';
                tooltip.style.left = info.x + 'px';
                tooltip.style.top = info.y + 'px';
            } else {
                tooltip.style.display = 'none';
            }
        }

        // ========== New Interactive Filter Functions ==========
        
        function toggleFilterMode(mode) {
            const interactiveMode = document.getElementById('interactiveMode');
            const traditionalMode = document.getElementById('traditionalMode');
            const buttons = document.querySelectorAll('.mode-btn');
            
            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            if (mode === 'interactive') {
                interactiveMode.style.display = 'block';
                traditionalMode.style.display = 'none';
            } else {
                interactiveMode.style.display = 'none';
                traditionalMode.style.display = 'block';
                // Re-attach traditional event listeners
                setupTraditionalListeners();
            }
        }

        function selectColorMode(element, mode) {
            // Update visual selection
            const items = element.parentElement.querySelectorAll('.filter-bar-item');
            items.forEach(item => item.classList.remove('active'));
            element.classList.add('active');
            
            // Apply filter
            switchColorMode(mode);
        }

        // 统计图表选择函数
        function selectRuralUrbanStat(element, type) {
            // Handle old stat bar interface if element is provided
            if (element && element.parentElement) {
            const bars = element.parentElement.querySelectorAll('.stat-bar');
            bars.forEach(bar => bar.classList.remove('active'));
            element.classList.add('active');
            }
            
            // Sync with hidden select
            const select = document.getElementById('ruralUrbanFilter');
            if (select) select.value = type;
            
            filterAndUpdate();
        }

        function selectTradeTypeStat(element, type) {
            // Handle old stat bar interface if element is provided
            if (element && element.parentElement) {
            const bars = element.parentElement.querySelectorAll('.stat-bar');
            bars.forEach(bar => bar.classList.remove('active'));
            element.classList.add('active');
            }
            
            // Sync with hidden select
            const select = document.getElementById('tradeTypeFilter');
            if (select) select.value = type;
            
            filterAndUpdate();
        }

        function selectYearStat(element, year) {
            // Handle old stat bar interface if element is provided
            if (element && element.parentElement) {
            const bars = element.parentElement.querySelectorAll('.stat-bar');
            bars.forEach(bar => bar.classList.remove('active'));
            element.classList.add('active');
            }
            
            // Sync with hidden select
            const select = document.getElementById('yearFilter');
            if (select) select.value = year;
            
            filterAndUpdate();
        }

        function selectRouteFilterStat(element, filter) {
            const bars = element.parentElement.querySelectorAll('.stat-bar');
            bars.forEach(bar => bar.classList.remove('active'));
            element.classList.add('active');
            
            // Sync with hidden select
            const select = document.getElementById('routeFilter');
            if (select) select.value = filter;
            
            switchDataSource(filter);
        }

        // 传统条形图选择函数
        function selectRuralUrban(element, type) {
            const items = element.parentElement.querySelectorAll('.filter-bar-item');
            items.forEach(item => item.classList.remove('active'));
            element.classList.add('active');
            
            // Sync with hidden select (for compatibility)
            const select = document.getElementById('ruralUrbanFilter');
            if (select) select.value = type;
            
            filterAndUpdate();
        }

        function selectTradeType(element, type) {
            const items = element.parentElement.querySelectorAll('.filter-bar-item');
            items.forEach(item => item.classList.remove('active'));
            element.classList.add('active');
            
            // Sync with hidden select
            const select = document.getElementById('tradeTypeFilter');
            if (select) select.value = type;
            
            filterAndUpdate();
        }

        function selectYear(element, year) {
            const buttons = element.parentElement.querySelectorAll('.year-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            element.classList.add('active');
            
            // Sync with hidden select
            const select = document.getElementById('yearFilter');
            if (select) select.value = year;
            
            filterAndUpdate();
        }

        function selectCommodity(element, commodity) {
            const cards = element.parentElement.querySelectorAll('.commodity-card');
            cards.forEach(card => card.classList.remove('active'));
            element.classList.add('active');
            
            // Sync with hidden select
            const select = document.getElementById('commodityFilter');
            if (select) select.value = commodity;
            
            switchToCommodity(commodity);
        }

        function selectTransport(element, transport) {
            const items = element.parentElement.querySelectorAll('.filter-bar-item');
            items.forEach(item => item.classList.remove('active'));
            element.classList.add('active');
            
            // Sync with hidden select
            const select = document.getElementById('transportFilter');
            if (select) select.value = transport;
            
            filterAndUpdate();
        }

        function selectRouteFilter(element, filter) {
            const items = element.parentElement.querySelectorAll('.filter-bar-item');
            items.forEach(item => item.classList.remove('active'));
            element.classList.add('active');
            
            // Sync with hidden select
            const select = document.getElementById('routeFilter');
            if (select) select.value = filter;
            
            switchDataSource(filter);
        }

        // ========== Original Event Listeners ==========

        function setupTraditionalListeners() {
            // Color mode switch
            const colorModeSelect = document.getElementById('colorModeSelect');
            if (colorModeSelect) {
                colorModeSelect.addEventListener('change', function() {
                switchColorMode(this.value);
            });
            }

            // Route filter dropdown
            const routeFilter = document.getElementById('routeFilter');
            if (routeFilter) {
                routeFilter.addEventListener('change', function() {
                switchDataSource(this.value);
            });
            }

            // Commodity filter
            const commodityFilter = document.getElementById('commodityFilter');
            if (commodityFilter) {
                commodityFilter.addEventListener('change', function() {
                switchToCommodity(this.value);
            });
            }

            // Other filters
            const yearFilter = document.getElementById('yearFilter');
            if (yearFilter) {
                yearFilter.addEventListener('change', filterAndUpdate);
            }

            const transportFilter = document.getElementById('transportFilter');
            if (transportFilter) {
                transportFilter.addEventListener('change', filterAndUpdate);
            }

            const tradeTypeFilter = document.getElementById('tradeTypeFilter');
            if (tradeTypeFilter) {
                tradeTypeFilter.addEventListener('change', filterAndUpdate);
            }

            const ruralUrbanFilter = document.getElementById('ruralUrbanFilter');
            if (ruralUrbanFilter) {
                ruralUrbanFilter.addEventListener('change', filterAndUpdate);
            }
        }

        function setupEventListeners() {
            // Set up traditional mode listeners (hidden by default)
            setupTraditionalListeners();
            
            // Arc width - real-time update
            document.getElementById('arcWidth').addEventListener('input', function() {
                const value = parseFloat(this.value).toFixed(1);
                document.getElementById('arcWidthValue').textContent = value;
                updateVisualization();
            });

            // Show points
            document.getElementById('showPoints').addEventListener('change', updateVisualization);
            
            // Show via city
            document.getElementById('showViaCity').addEventListener('change', updateVisualization);
        }


        // Initialize
        init();
    </script>
</body>
</html>


